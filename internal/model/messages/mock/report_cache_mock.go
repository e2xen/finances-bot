package mock

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i max.ks1230/project-base/internal/model/messages.reportCache -o ./mock/report_cache_mock.go -n ReportCacheMock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ReportCacheMock implements messages.reportCache
type ReportCacheMock struct {
	t minimock.Tester

	funcCacheReport          func(userID int64, option string, report string) (err error)
	inspectFuncCacheReport   func(userID int64, option string, report string)
	afterCacheReportCounter  uint64
	beforeCacheReportCounter uint64
	CacheReportMock          mReportCacheMockCacheReport

	funcGetReport          func(userID int64, option string) (s1 string, err error)
	inspectFuncGetReport   func(userID int64, option string)
	afterGetReportCounter  uint64
	beforeGetReportCounter uint64
	GetReportMock          mReportCacheMockGetReport

	funcInvalidateCache          func(userID int64, options []string) (err error)
	inspectFuncInvalidateCache   func(userID int64, options []string)
	afterInvalidateCacheCounter  uint64
	beforeInvalidateCacheCounter uint64
	InvalidateCacheMock          mReportCacheMockInvalidateCache
}

// NewReportCacheMock returns a mock for messages.reportCache
func NewReportCacheMock(t minimock.Tester) *ReportCacheMock {
	m := &ReportCacheMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CacheReportMock = mReportCacheMockCacheReport{mock: m}
	m.CacheReportMock.callArgs = []*ReportCacheMockCacheReportParams{}

	m.GetReportMock = mReportCacheMockGetReport{mock: m}
	m.GetReportMock.callArgs = []*ReportCacheMockGetReportParams{}

	m.InvalidateCacheMock = mReportCacheMockInvalidateCache{mock: m}
	m.InvalidateCacheMock.callArgs = []*ReportCacheMockInvalidateCacheParams{}

	return m
}

type mReportCacheMockCacheReport struct {
	mock               *ReportCacheMock
	defaultExpectation *ReportCacheMockCacheReportExpectation
	expectations       []*ReportCacheMockCacheReportExpectation

	callArgs []*ReportCacheMockCacheReportParams
	mutex    sync.RWMutex
}

// ReportCacheMockCacheReportExpectation specifies expectation struct of the reportCache.CacheReport
type ReportCacheMockCacheReportExpectation struct {
	mock    *ReportCacheMock
	params  *ReportCacheMockCacheReportParams
	results *ReportCacheMockCacheReportResults
	Counter uint64
}

// ReportCacheMockCacheReportParams contains parameters of the reportCache.CacheReport
type ReportCacheMockCacheReportParams struct {
	userID int64
	option string
	report string
}

// ReportCacheMockCacheReportResults contains results of the reportCache.CacheReport
type ReportCacheMockCacheReportResults struct {
	err error
}

// Expect sets up expected params for reportCache.CacheReport
func (mmCacheReport *mReportCacheMockCacheReport) Expect(userID int64, option string, report string) *mReportCacheMockCacheReport {
	if mmCacheReport.mock.funcCacheReport != nil {
		mmCacheReport.mock.t.Fatalf("ReportCacheMock.CacheReport mock is already set by Set")
	}

	if mmCacheReport.defaultExpectation == nil {
		mmCacheReport.defaultExpectation = &ReportCacheMockCacheReportExpectation{}
	}

	mmCacheReport.defaultExpectation.params = &ReportCacheMockCacheReportParams{userID, option, report}
	for _, e := range mmCacheReport.expectations {
		if minimock.Equal(e.params, mmCacheReport.defaultExpectation.params) {
			mmCacheReport.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCacheReport.defaultExpectation.params)
		}
	}

	return mmCacheReport
}

// Inspect accepts an inspector function that has same arguments as the reportCache.CacheReport
func (mmCacheReport *mReportCacheMockCacheReport) Inspect(f func(userID int64, option string, report string)) *mReportCacheMockCacheReport {
	if mmCacheReport.mock.inspectFuncCacheReport != nil {
		mmCacheReport.mock.t.Fatalf("Inspect function is already set for ReportCacheMock.CacheReport")
	}

	mmCacheReport.mock.inspectFuncCacheReport = f

	return mmCacheReport
}

// Return sets up results that will be returned by reportCache.CacheReport
func (mmCacheReport *mReportCacheMockCacheReport) Return(err error) *ReportCacheMock {
	if mmCacheReport.mock.funcCacheReport != nil {
		mmCacheReport.mock.t.Fatalf("ReportCacheMock.CacheReport mock is already set by Set")
	}

	if mmCacheReport.defaultExpectation == nil {
		mmCacheReport.defaultExpectation = &ReportCacheMockCacheReportExpectation{mock: mmCacheReport.mock}
	}
	mmCacheReport.defaultExpectation.results = &ReportCacheMockCacheReportResults{err}
	return mmCacheReport.mock
}

// Set uses given function f to mock the reportCache.CacheReport method
func (mmCacheReport *mReportCacheMockCacheReport) Set(f func(userID int64, option string, report string) (err error)) *ReportCacheMock {
	if mmCacheReport.defaultExpectation != nil {
		mmCacheReport.mock.t.Fatalf("Default expectation is already set for the reportCache.CacheReport method")
	}

	if len(mmCacheReport.expectations) > 0 {
		mmCacheReport.mock.t.Fatalf("Some expectations are already set for the reportCache.CacheReport method")
	}

	mmCacheReport.mock.funcCacheReport = f
	return mmCacheReport.mock
}

// When sets expectation for the reportCache.CacheReport which will trigger the result defined by the following
// Then helper
func (mmCacheReport *mReportCacheMockCacheReport) When(userID int64, option string, report string) *ReportCacheMockCacheReportExpectation {
	if mmCacheReport.mock.funcCacheReport != nil {
		mmCacheReport.mock.t.Fatalf("ReportCacheMock.CacheReport mock is already set by Set")
	}

	expectation := &ReportCacheMockCacheReportExpectation{
		mock:   mmCacheReport.mock,
		params: &ReportCacheMockCacheReportParams{userID, option, report},
	}
	mmCacheReport.expectations = append(mmCacheReport.expectations, expectation)
	return expectation
}

// Then sets up reportCache.CacheReport return parameters for the expectation previously defined by the When method
func (e *ReportCacheMockCacheReportExpectation) Then(err error) *ReportCacheMock {
	e.results = &ReportCacheMockCacheReportResults{err}
	return e.mock
}

// CacheReport implements messages.reportCache
func (mmCacheReport *ReportCacheMock) CacheReport(userID int64, option string, report string) (err error) {
	mm_atomic.AddUint64(&mmCacheReport.beforeCacheReportCounter, 1)
	defer mm_atomic.AddUint64(&mmCacheReport.afterCacheReportCounter, 1)

	if mmCacheReport.inspectFuncCacheReport != nil {
		mmCacheReport.inspectFuncCacheReport(userID, option, report)
	}

	mm_params := &ReportCacheMockCacheReportParams{userID, option, report}

	// Record call args
	mmCacheReport.CacheReportMock.mutex.Lock()
	mmCacheReport.CacheReportMock.callArgs = append(mmCacheReport.CacheReportMock.callArgs, mm_params)
	mmCacheReport.CacheReportMock.mutex.Unlock()

	for _, e := range mmCacheReport.CacheReportMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCacheReport.CacheReportMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCacheReport.CacheReportMock.defaultExpectation.Counter, 1)
		mm_want := mmCacheReport.CacheReportMock.defaultExpectation.params
		mm_got := ReportCacheMockCacheReportParams{userID, option, report}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCacheReport.t.Errorf("ReportCacheMock.CacheReport got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCacheReport.CacheReportMock.defaultExpectation.results
		if mm_results == nil {
			mmCacheReport.t.Fatal("No results are set for the ReportCacheMock.CacheReport")
		}
		return (*mm_results).err
	}
	if mmCacheReport.funcCacheReport != nil {
		return mmCacheReport.funcCacheReport(userID, option, report)
	}
	mmCacheReport.t.Fatalf("Unexpected call to ReportCacheMock.CacheReport. %v %v %v", userID, option, report)
	return
}

// CacheReportAfterCounter returns a count of finished ReportCacheMock.CacheReport invocations
func (mmCacheReport *ReportCacheMock) CacheReportAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCacheReport.afterCacheReportCounter)
}

// CacheReportBeforeCounter returns a count of ReportCacheMock.CacheReport invocations
func (mmCacheReport *ReportCacheMock) CacheReportBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCacheReport.beforeCacheReportCounter)
}

// Calls returns a list of arguments used in each call to ReportCacheMock.CacheReport.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCacheReport *mReportCacheMockCacheReport) Calls() []*ReportCacheMockCacheReportParams {
	mmCacheReport.mutex.RLock()

	argCopy := make([]*ReportCacheMockCacheReportParams, len(mmCacheReport.callArgs))
	copy(argCopy, mmCacheReport.callArgs)

	mmCacheReport.mutex.RUnlock()

	return argCopy
}

// MinimockCacheReportDone returns true if the count of the CacheReport invocations corresponds
// the number of defined expectations
func (m *ReportCacheMock) MinimockCacheReportDone() bool {
	for _, e := range m.CacheReportMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CacheReportMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCacheReportCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCacheReport != nil && mm_atomic.LoadUint64(&m.afterCacheReportCounter) < 1 {
		return false
	}
	return true
}

// MinimockCacheReportInspect logs each unmet expectation
func (m *ReportCacheMock) MinimockCacheReportInspect() {
	for _, e := range m.CacheReportMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReportCacheMock.CacheReport with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CacheReportMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCacheReportCounter) < 1 {
		if m.CacheReportMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ReportCacheMock.CacheReport")
		} else {
			m.t.Errorf("Expected call to ReportCacheMock.CacheReport with params: %#v", *m.CacheReportMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCacheReport != nil && mm_atomic.LoadUint64(&m.afterCacheReportCounter) < 1 {
		m.t.Error("Expected call to ReportCacheMock.CacheReport")
	}
}

type mReportCacheMockGetReport struct {
	mock               *ReportCacheMock
	defaultExpectation *ReportCacheMockGetReportExpectation
	expectations       []*ReportCacheMockGetReportExpectation

	callArgs []*ReportCacheMockGetReportParams
	mutex    sync.RWMutex
}

// ReportCacheMockGetReportExpectation specifies expectation struct of the reportCache.GetReport
type ReportCacheMockGetReportExpectation struct {
	mock    *ReportCacheMock
	params  *ReportCacheMockGetReportParams
	results *ReportCacheMockGetReportResults
	Counter uint64
}

// ReportCacheMockGetReportParams contains parameters of the reportCache.GetReport
type ReportCacheMockGetReportParams struct {
	userID int64
	option string
}

// ReportCacheMockGetReportResults contains results of the reportCache.GetReport
type ReportCacheMockGetReportResults struct {
	s1  string
	err error
}

// Expect sets up expected params for reportCache.GetReport
func (mmGetReport *mReportCacheMockGetReport) Expect(userID int64, option string) *mReportCacheMockGetReport {
	if mmGetReport.mock.funcGetReport != nil {
		mmGetReport.mock.t.Fatalf("ReportCacheMock.GetReport mock is already set by Set")
	}

	if mmGetReport.defaultExpectation == nil {
		mmGetReport.defaultExpectation = &ReportCacheMockGetReportExpectation{}
	}

	mmGetReport.defaultExpectation.params = &ReportCacheMockGetReportParams{userID, option}
	for _, e := range mmGetReport.expectations {
		if minimock.Equal(e.params, mmGetReport.defaultExpectation.params) {
			mmGetReport.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetReport.defaultExpectation.params)
		}
	}

	return mmGetReport
}

// Inspect accepts an inspector function that has same arguments as the reportCache.GetReport
func (mmGetReport *mReportCacheMockGetReport) Inspect(f func(userID int64, option string)) *mReportCacheMockGetReport {
	if mmGetReport.mock.inspectFuncGetReport != nil {
		mmGetReport.mock.t.Fatalf("Inspect function is already set for ReportCacheMock.GetReport")
	}

	mmGetReport.mock.inspectFuncGetReport = f

	return mmGetReport
}

// Return sets up results that will be returned by reportCache.GetReport
func (mmGetReport *mReportCacheMockGetReport) Return(s1 string, err error) *ReportCacheMock {
	if mmGetReport.mock.funcGetReport != nil {
		mmGetReport.mock.t.Fatalf("ReportCacheMock.GetReport mock is already set by Set")
	}

	if mmGetReport.defaultExpectation == nil {
		mmGetReport.defaultExpectation = &ReportCacheMockGetReportExpectation{mock: mmGetReport.mock}
	}
	mmGetReport.defaultExpectation.results = &ReportCacheMockGetReportResults{s1, err}
	return mmGetReport.mock
}

// Set uses given function f to mock the reportCache.GetReport method
func (mmGetReport *mReportCacheMockGetReport) Set(f func(userID int64, option string) (s1 string, err error)) *ReportCacheMock {
	if mmGetReport.defaultExpectation != nil {
		mmGetReport.mock.t.Fatalf("Default expectation is already set for the reportCache.GetReport method")
	}

	if len(mmGetReport.expectations) > 0 {
		mmGetReport.mock.t.Fatalf("Some expectations are already set for the reportCache.GetReport method")
	}

	mmGetReport.mock.funcGetReport = f
	return mmGetReport.mock
}

// When sets expectation for the reportCache.GetReport which will trigger the result defined by the following
// Then helper
func (mmGetReport *mReportCacheMockGetReport) When(userID int64, option string) *ReportCacheMockGetReportExpectation {
	if mmGetReport.mock.funcGetReport != nil {
		mmGetReport.mock.t.Fatalf("ReportCacheMock.GetReport mock is already set by Set")
	}

	expectation := &ReportCacheMockGetReportExpectation{
		mock:   mmGetReport.mock,
		params: &ReportCacheMockGetReportParams{userID, option},
	}
	mmGetReport.expectations = append(mmGetReport.expectations, expectation)
	return expectation
}

// Then sets up reportCache.GetReport return parameters for the expectation previously defined by the When method
func (e *ReportCacheMockGetReportExpectation) Then(s1 string, err error) *ReportCacheMock {
	e.results = &ReportCacheMockGetReportResults{s1, err}
	return e.mock
}

// GetReport implements messages.reportCache
func (mmGetReport *ReportCacheMock) GetReport(userID int64, option string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetReport.beforeGetReportCounter, 1)
	defer mm_atomic.AddUint64(&mmGetReport.afterGetReportCounter, 1)

	if mmGetReport.inspectFuncGetReport != nil {
		mmGetReport.inspectFuncGetReport(userID, option)
	}

	mm_params := &ReportCacheMockGetReportParams{userID, option}

	// Record call args
	mmGetReport.GetReportMock.mutex.Lock()
	mmGetReport.GetReportMock.callArgs = append(mmGetReport.GetReportMock.callArgs, mm_params)
	mmGetReport.GetReportMock.mutex.Unlock()

	for _, e := range mmGetReport.GetReportMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetReport.GetReportMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetReport.GetReportMock.defaultExpectation.Counter, 1)
		mm_want := mmGetReport.GetReportMock.defaultExpectation.params
		mm_got := ReportCacheMockGetReportParams{userID, option}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetReport.t.Errorf("ReportCacheMock.GetReport got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetReport.GetReportMock.defaultExpectation.results
		if mm_results == nil {
			mmGetReport.t.Fatal("No results are set for the ReportCacheMock.GetReport")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetReport.funcGetReport != nil {
		return mmGetReport.funcGetReport(userID, option)
	}
	mmGetReport.t.Fatalf("Unexpected call to ReportCacheMock.GetReport. %v %v", userID, option)
	return
}

// GetReportAfterCounter returns a count of finished ReportCacheMock.GetReport invocations
func (mmGetReport *ReportCacheMock) GetReportAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReport.afterGetReportCounter)
}

// GetReportBeforeCounter returns a count of ReportCacheMock.GetReport invocations
func (mmGetReport *ReportCacheMock) GetReportBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReport.beforeGetReportCounter)
}

// Calls returns a list of arguments used in each call to ReportCacheMock.GetReport.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetReport *mReportCacheMockGetReport) Calls() []*ReportCacheMockGetReportParams {
	mmGetReport.mutex.RLock()

	argCopy := make([]*ReportCacheMockGetReportParams, len(mmGetReport.callArgs))
	copy(argCopy, mmGetReport.callArgs)

	mmGetReport.mutex.RUnlock()

	return argCopy
}

// MinimockGetReportDone returns true if the count of the GetReport invocations corresponds
// the number of defined expectations
func (m *ReportCacheMock) MinimockGetReportDone() bool {
	for _, e := range m.GetReportMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetReportMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetReportCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetReport != nil && mm_atomic.LoadUint64(&m.afterGetReportCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetReportInspect logs each unmet expectation
func (m *ReportCacheMock) MinimockGetReportInspect() {
	for _, e := range m.GetReportMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReportCacheMock.GetReport with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetReportMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetReportCounter) < 1 {
		if m.GetReportMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ReportCacheMock.GetReport")
		} else {
			m.t.Errorf("Expected call to ReportCacheMock.GetReport with params: %#v", *m.GetReportMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetReport != nil && mm_atomic.LoadUint64(&m.afterGetReportCounter) < 1 {
		m.t.Error("Expected call to ReportCacheMock.GetReport")
	}
}

type mReportCacheMockInvalidateCache struct {
	mock               *ReportCacheMock
	defaultExpectation *ReportCacheMockInvalidateCacheExpectation
	expectations       []*ReportCacheMockInvalidateCacheExpectation

	callArgs []*ReportCacheMockInvalidateCacheParams
	mutex    sync.RWMutex
}

// ReportCacheMockInvalidateCacheExpectation specifies expectation struct of the reportCache.InvalidateCache
type ReportCacheMockInvalidateCacheExpectation struct {
	mock    *ReportCacheMock
	params  *ReportCacheMockInvalidateCacheParams
	results *ReportCacheMockInvalidateCacheResults
	Counter uint64
}

// ReportCacheMockInvalidateCacheParams contains parameters of the reportCache.InvalidateCache
type ReportCacheMockInvalidateCacheParams struct {
	userID  int64
	options []string
}

// ReportCacheMockInvalidateCacheResults contains results of the reportCache.InvalidateCache
type ReportCacheMockInvalidateCacheResults struct {
	err error
}

// Expect sets up expected params for reportCache.InvalidateCache
func (mmInvalidateCache *mReportCacheMockInvalidateCache) Expect(userID int64, options []string) *mReportCacheMockInvalidateCache {
	if mmInvalidateCache.mock.funcInvalidateCache != nil {
		mmInvalidateCache.mock.t.Fatalf("ReportCacheMock.InvalidateCache mock is already set by Set")
	}

	if mmInvalidateCache.defaultExpectation == nil {
		mmInvalidateCache.defaultExpectation = &ReportCacheMockInvalidateCacheExpectation{}
	}

	mmInvalidateCache.defaultExpectation.params = &ReportCacheMockInvalidateCacheParams{userID, options}
	for _, e := range mmInvalidateCache.expectations {
		if minimock.Equal(e.params, mmInvalidateCache.defaultExpectation.params) {
			mmInvalidateCache.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInvalidateCache.defaultExpectation.params)
		}
	}

	return mmInvalidateCache
}

// Inspect accepts an inspector function that has same arguments as the reportCache.InvalidateCache
func (mmInvalidateCache *mReportCacheMockInvalidateCache) Inspect(f func(userID int64, options []string)) *mReportCacheMockInvalidateCache {
	if mmInvalidateCache.mock.inspectFuncInvalidateCache != nil {
		mmInvalidateCache.mock.t.Fatalf("Inspect function is already set for ReportCacheMock.InvalidateCache")
	}

	mmInvalidateCache.mock.inspectFuncInvalidateCache = f

	return mmInvalidateCache
}

// Return sets up results that will be returned by reportCache.InvalidateCache
func (mmInvalidateCache *mReportCacheMockInvalidateCache) Return(err error) *ReportCacheMock {
	if mmInvalidateCache.mock.funcInvalidateCache != nil {
		mmInvalidateCache.mock.t.Fatalf("ReportCacheMock.InvalidateCache mock is already set by Set")
	}

	if mmInvalidateCache.defaultExpectation == nil {
		mmInvalidateCache.defaultExpectation = &ReportCacheMockInvalidateCacheExpectation{mock: mmInvalidateCache.mock}
	}
	mmInvalidateCache.defaultExpectation.results = &ReportCacheMockInvalidateCacheResults{err}
	return mmInvalidateCache.mock
}

// Set uses given function f to mock the reportCache.InvalidateCache method
func (mmInvalidateCache *mReportCacheMockInvalidateCache) Set(f func(userID int64, options []string) (err error)) *ReportCacheMock {
	if mmInvalidateCache.defaultExpectation != nil {
		mmInvalidateCache.mock.t.Fatalf("Default expectation is already set for the reportCache.InvalidateCache method")
	}

	if len(mmInvalidateCache.expectations) > 0 {
		mmInvalidateCache.mock.t.Fatalf("Some expectations are already set for the reportCache.InvalidateCache method")
	}

	mmInvalidateCache.mock.funcInvalidateCache = f
	return mmInvalidateCache.mock
}

// When sets expectation for the reportCache.InvalidateCache which will trigger the result defined by the following
// Then helper
func (mmInvalidateCache *mReportCacheMockInvalidateCache) When(userID int64, options []string) *ReportCacheMockInvalidateCacheExpectation {
	if mmInvalidateCache.mock.funcInvalidateCache != nil {
		mmInvalidateCache.mock.t.Fatalf("ReportCacheMock.InvalidateCache mock is already set by Set")
	}

	expectation := &ReportCacheMockInvalidateCacheExpectation{
		mock:   mmInvalidateCache.mock,
		params: &ReportCacheMockInvalidateCacheParams{userID, options},
	}
	mmInvalidateCache.expectations = append(mmInvalidateCache.expectations, expectation)
	return expectation
}

// Then sets up reportCache.InvalidateCache return parameters for the expectation previously defined by the When method
func (e *ReportCacheMockInvalidateCacheExpectation) Then(err error) *ReportCacheMock {
	e.results = &ReportCacheMockInvalidateCacheResults{err}
	return e.mock
}

// InvalidateCache implements messages.reportCache
func (mmInvalidateCache *ReportCacheMock) InvalidateCache(userID int64, options []string) (err error) {
	mm_atomic.AddUint64(&mmInvalidateCache.beforeInvalidateCacheCounter, 1)
	defer mm_atomic.AddUint64(&mmInvalidateCache.afterInvalidateCacheCounter, 1)

	if mmInvalidateCache.inspectFuncInvalidateCache != nil {
		mmInvalidateCache.inspectFuncInvalidateCache(userID, options)
	}

	mm_params := &ReportCacheMockInvalidateCacheParams{userID, options}

	// Record call args
	mmInvalidateCache.InvalidateCacheMock.mutex.Lock()
	mmInvalidateCache.InvalidateCacheMock.callArgs = append(mmInvalidateCache.InvalidateCacheMock.callArgs, mm_params)
	mmInvalidateCache.InvalidateCacheMock.mutex.Unlock()

	for _, e := range mmInvalidateCache.InvalidateCacheMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmInvalidateCache.InvalidateCacheMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInvalidateCache.InvalidateCacheMock.defaultExpectation.Counter, 1)
		mm_want := mmInvalidateCache.InvalidateCacheMock.defaultExpectation.params
		mm_got := ReportCacheMockInvalidateCacheParams{userID, options}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInvalidateCache.t.Errorf("ReportCacheMock.InvalidateCache got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInvalidateCache.InvalidateCacheMock.defaultExpectation.results
		if mm_results == nil {
			mmInvalidateCache.t.Fatal("No results are set for the ReportCacheMock.InvalidateCache")
		}
		return (*mm_results).err
	}
	if mmInvalidateCache.funcInvalidateCache != nil {
		return mmInvalidateCache.funcInvalidateCache(userID, options)
	}
	mmInvalidateCache.t.Fatalf("Unexpected call to ReportCacheMock.InvalidateCache. %v %v", userID, options)
	return
}

// InvalidateCacheAfterCounter returns a count of finished ReportCacheMock.InvalidateCache invocations
func (mmInvalidateCache *ReportCacheMock) InvalidateCacheAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInvalidateCache.afterInvalidateCacheCounter)
}

// InvalidateCacheBeforeCounter returns a count of ReportCacheMock.InvalidateCache invocations
func (mmInvalidateCache *ReportCacheMock) InvalidateCacheBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInvalidateCache.beforeInvalidateCacheCounter)
}

// Calls returns a list of arguments used in each call to ReportCacheMock.InvalidateCache.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInvalidateCache *mReportCacheMockInvalidateCache) Calls() []*ReportCacheMockInvalidateCacheParams {
	mmInvalidateCache.mutex.RLock()

	argCopy := make([]*ReportCacheMockInvalidateCacheParams, len(mmInvalidateCache.callArgs))
	copy(argCopy, mmInvalidateCache.callArgs)

	mmInvalidateCache.mutex.RUnlock()

	return argCopy
}

// MinimockInvalidateCacheDone returns true if the count of the InvalidateCache invocations corresponds
// the number of defined expectations
func (m *ReportCacheMock) MinimockInvalidateCacheDone() bool {
	for _, e := range m.InvalidateCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InvalidateCacheMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInvalidateCacheCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInvalidateCache != nil && mm_atomic.LoadUint64(&m.afterInvalidateCacheCounter) < 1 {
		return false
	}
	return true
}

// MinimockInvalidateCacheInspect logs each unmet expectation
func (m *ReportCacheMock) MinimockInvalidateCacheInspect() {
	for _, e := range m.InvalidateCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReportCacheMock.InvalidateCache with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InvalidateCacheMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInvalidateCacheCounter) < 1 {
		if m.InvalidateCacheMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ReportCacheMock.InvalidateCache")
		} else {
			m.t.Errorf("Expected call to ReportCacheMock.InvalidateCache with params: %#v", *m.InvalidateCacheMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInvalidateCache != nil && mm_atomic.LoadUint64(&m.afterInvalidateCacheCounter) < 1 {
		m.t.Error("Expected call to ReportCacheMock.InvalidateCache")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ReportCacheMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCacheReportInspect()

		m.MinimockGetReportInspect()

		m.MinimockInvalidateCacheInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ReportCacheMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ReportCacheMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCacheReportDone() &&
		m.MinimockGetReportDone() &&
		m.MinimockInvalidateCacheDone()
}
