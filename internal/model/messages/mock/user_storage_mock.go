package mock

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i max.ks1230/project-base/internal/model/messages.userStorage -o ./mock/user_storage_mock.go -n UserStorageMock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"max.ks1230/project-base/internal/entity/currency"
	"max.ks1230/project-base/internal/entity/user"
)

// UserStorageMock implements messages.userStorage
type UserStorageMock struct {
	t minimock.Tester

	funcGetRate          func(name string) (r1 currency.Rate, err error)
	inspectFuncGetRate   func(name string)
	afterGetRateCounter  uint64
	beforeGetRateCounter uint64
	GetRateMock          mUserStorageMockGetRate

	funcGetUserByID          func(userID int64) (r1 user.Record, err error)
	inspectFuncGetUserByID   func(userID int64)
	afterGetUserByIDCounter  uint64
	beforeGetUserByIDCounter uint64
	GetUserByIDMock          mUserStorageMockGetUserByID

	funcSaveUserByID          func(userID int64, rec user.Record) (err error)
	inspectFuncSaveUserByID   func(userID int64, rec user.Record)
	afterSaveUserByIDCounter  uint64
	beforeSaveUserByIDCounter uint64
	SaveUserByIDMock          mUserStorageMockSaveUserByID

	funcSetCurrencyForUser          func(userID int64, curr string) (err error)
	inspectFuncSetCurrencyForUser   func(userID int64, curr string)
	afterSetCurrencyForUserCounter  uint64
	beforeSetCurrencyForUserCounter uint64
	SetCurrencyForUserMock          mUserStorageMockSetCurrencyForUser
}

// NewUserStorageMock returns a mock for messages.userStorage
func NewUserStorageMock(t minimock.Tester) *UserStorageMock {
	m := &UserStorageMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetRateMock = mUserStorageMockGetRate{mock: m}
	m.GetRateMock.callArgs = []*UserStorageMockGetRateParams{}

	m.GetUserByIDMock = mUserStorageMockGetUserByID{mock: m}
	m.GetUserByIDMock.callArgs = []*UserStorageMockGetUserByIDParams{}

	m.SaveUserByIDMock = mUserStorageMockSaveUserByID{mock: m}
	m.SaveUserByIDMock.callArgs = []*UserStorageMockSaveUserByIDParams{}

	m.SetCurrencyForUserMock = mUserStorageMockSetCurrencyForUser{mock: m}
	m.SetCurrencyForUserMock.callArgs = []*UserStorageMockSetCurrencyForUserParams{}

	return m
}

type mUserStorageMockGetRate struct {
	mock               *UserStorageMock
	defaultExpectation *UserStorageMockGetRateExpectation
	expectations       []*UserStorageMockGetRateExpectation

	callArgs []*UserStorageMockGetRateParams
	mutex    sync.RWMutex
}

// UserStorageMockGetRateExpectation specifies expectation struct of the userStorage.GetRate
type UserStorageMockGetRateExpectation struct {
	mock    *UserStorageMock
	params  *UserStorageMockGetRateParams
	results *UserStorageMockGetRateResults
	Counter uint64
}

// UserStorageMockGetRateParams contains parameters of the userStorage.GetRate
type UserStorageMockGetRateParams struct {
	name string
}

// UserStorageMockGetRateResults contains results of the userStorage.GetRate
type UserStorageMockGetRateResults struct {
	r1  currency.Rate
	err error
}

// Expect sets up expected params for userStorage.GetRate
func (mmGetRate *mUserStorageMockGetRate) Expect(name string) *mUserStorageMockGetRate {
	if mmGetRate.mock.funcGetRate != nil {
		mmGetRate.mock.t.Fatalf("UserStorageMock.GetRate mock is already set by Set")
	}

	if mmGetRate.defaultExpectation == nil {
		mmGetRate.defaultExpectation = &UserStorageMockGetRateExpectation{}
	}

	mmGetRate.defaultExpectation.params = &UserStorageMockGetRateParams{name}
	for _, e := range mmGetRate.expectations {
		if minimock.Equal(e.params, mmGetRate.defaultExpectation.params) {
			mmGetRate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRate.defaultExpectation.params)
		}
	}

	return mmGetRate
}

// Inspect accepts an inspector function that has same arguments as the userStorage.GetRate
func (mmGetRate *mUserStorageMockGetRate) Inspect(f func(name string)) *mUserStorageMockGetRate {
	if mmGetRate.mock.inspectFuncGetRate != nil {
		mmGetRate.mock.t.Fatalf("Inspect function is already set for UserStorageMock.GetRate")
	}

	mmGetRate.mock.inspectFuncGetRate = f

	return mmGetRate
}

// Return sets up results that will be returned by userStorage.GetRate
func (mmGetRate *mUserStorageMockGetRate) Return(r1 currency.Rate, err error) *UserStorageMock {
	if mmGetRate.mock.funcGetRate != nil {
		mmGetRate.mock.t.Fatalf("UserStorageMock.GetRate mock is already set by Set")
	}

	if mmGetRate.defaultExpectation == nil {
		mmGetRate.defaultExpectation = &UserStorageMockGetRateExpectation{mock: mmGetRate.mock}
	}
	mmGetRate.defaultExpectation.results = &UserStorageMockGetRateResults{r1, err}
	return mmGetRate.mock
}

// Set uses given function f to mock the userStorage.GetRate method
func (mmGetRate *mUserStorageMockGetRate) Set(f func(name string) (r1 currency.Rate, err error)) *UserStorageMock {
	if mmGetRate.defaultExpectation != nil {
		mmGetRate.mock.t.Fatalf("Default expectation is already set for the userStorage.GetRate method")
	}

	if len(mmGetRate.expectations) > 0 {
		mmGetRate.mock.t.Fatalf("Some expectations are already set for the userStorage.GetRate method")
	}

	mmGetRate.mock.funcGetRate = f
	return mmGetRate.mock
}

// When sets expectation for the userStorage.GetRate which will trigger the result defined by the following
// Then helper
func (mmGetRate *mUserStorageMockGetRate) When(name string) *UserStorageMockGetRateExpectation {
	if mmGetRate.mock.funcGetRate != nil {
		mmGetRate.mock.t.Fatalf("UserStorageMock.GetRate mock is already set by Set")
	}

	expectation := &UserStorageMockGetRateExpectation{
		mock:   mmGetRate.mock,
		params: &UserStorageMockGetRateParams{name},
	}
	mmGetRate.expectations = append(mmGetRate.expectations, expectation)
	return expectation
}

// Then sets up userStorage.GetRate return parameters for the expectation previously defined by the When method
func (e *UserStorageMockGetRateExpectation) Then(r1 currency.Rate, err error) *UserStorageMock {
	e.results = &UserStorageMockGetRateResults{r1, err}
	return e.mock
}

// GetRate implements messages.userStorage
func (mmGetRate *UserStorageMock) GetRate(name string) (r1 currency.Rate, err error) {
	mm_atomic.AddUint64(&mmGetRate.beforeGetRateCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRate.afterGetRateCounter, 1)

	if mmGetRate.inspectFuncGetRate != nil {
		mmGetRate.inspectFuncGetRate(name)
	}

	mm_params := &UserStorageMockGetRateParams{name}

	// Record call args
	mmGetRate.GetRateMock.mutex.Lock()
	mmGetRate.GetRateMock.callArgs = append(mmGetRate.GetRateMock.callArgs, mm_params)
	mmGetRate.GetRateMock.mutex.Unlock()

	for _, e := range mmGetRate.GetRateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmGetRate.GetRateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRate.GetRateMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRate.GetRateMock.defaultExpectation.params
		mm_got := UserStorageMockGetRateParams{name}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRate.t.Errorf("UserStorageMock.GetRate got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRate.GetRateMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRate.t.Fatal("No results are set for the UserStorageMock.GetRate")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmGetRate.funcGetRate != nil {
		return mmGetRate.funcGetRate(name)
	}
	mmGetRate.t.Fatalf("Unexpected call to UserStorageMock.GetRate. %v", name)
	return
}

// GetRateAfterCounter returns a count of finished UserStorageMock.GetRate invocations
func (mmGetRate *UserStorageMock) GetRateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRate.afterGetRateCounter)
}

// GetRateBeforeCounter returns a count of UserStorageMock.GetRate invocations
func (mmGetRate *UserStorageMock) GetRateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRate.beforeGetRateCounter)
}

// Calls returns a list of arguments used in each call to UserStorageMock.GetRate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRate *mUserStorageMockGetRate) Calls() []*UserStorageMockGetRateParams {
	mmGetRate.mutex.RLock()

	argCopy := make([]*UserStorageMockGetRateParams, len(mmGetRate.callArgs))
	copy(argCopy, mmGetRate.callArgs)

	mmGetRate.mutex.RUnlock()

	return argCopy
}

// MinimockGetRateDone returns true if the count of the GetRate invocations corresponds
// the number of defined expectations
func (m *UserStorageMock) MinimockGetRateDone() bool {
	for _, e := range m.GetRateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRate != nil && mm_atomic.LoadUint64(&m.afterGetRateCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetRateInspect logs each unmet expectation
func (m *UserStorageMock) MinimockGetRateInspect() {
	for _, e := range m.GetRateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserStorageMock.GetRate with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRateCounter) < 1 {
		if m.GetRateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserStorageMock.GetRate")
		} else {
			m.t.Errorf("Expected call to UserStorageMock.GetRate with params: %#v", *m.GetRateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRate != nil && mm_atomic.LoadUint64(&m.afterGetRateCounter) < 1 {
		m.t.Error("Expected call to UserStorageMock.GetRate")
	}
}

type mUserStorageMockGetUserByID struct {
	mock               *UserStorageMock
	defaultExpectation *UserStorageMockGetUserByIDExpectation
	expectations       []*UserStorageMockGetUserByIDExpectation

	callArgs []*UserStorageMockGetUserByIDParams
	mutex    sync.RWMutex
}

// UserStorageMockGetUserByIDExpectation specifies expectation struct of the userStorage.GetUserByID
type UserStorageMockGetUserByIDExpectation struct {
	mock    *UserStorageMock
	params  *UserStorageMockGetUserByIDParams
	results *UserStorageMockGetUserByIDResults
	Counter uint64
}

// UserStorageMockGetUserByIDParams contains parameters of the userStorage.GetUserByID
type UserStorageMockGetUserByIDParams struct {
	userID int64
}

// UserStorageMockGetUserByIDResults contains results of the userStorage.GetUserByID
type UserStorageMockGetUserByIDResults struct {
	r1  user.Record
	err error
}

// Expect sets up expected params for userStorage.GetUserByID
func (mmGetUserByID *mUserStorageMockGetUserByID) Expect(userID int64) *mUserStorageMockGetUserByID {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("UserStorageMock.GetUserByID mock is already set by Set")
	}

	if mmGetUserByID.defaultExpectation == nil {
		mmGetUserByID.defaultExpectation = &UserStorageMockGetUserByIDExpectation{}
	}

	mmGetUserByID.defaultExpectation.params = &UserStorageMockGetUserByIDParams{userID}
	for _, e := range mmGetUserByID.expectations {
		if minimock.Equal(e.params, mmGetUserByID.defaultExpectation.params) {
			mmGetUserByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserByID.defaultExpectation.params)
		}
	}

	return mmGetUserByID
}

// Inspect accepts an inspector function that has same arguments as the userStorage.GetUserByID
func (mmGetUserByID *mUserStorageMockGetUserByID) Inspect(f func(userID int64)) *mUserStorageMockGetUserByID {
	if mmGetUserByID.mock.inspectFuncGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("Inspect function is already set for UserStorageMock.GetUserByID")
	}

	mmGetUserByID.mock.inspectFuncGetUserByID = f

	return mmGetUserByID
}

// Return sets up results that will be returned by userStorage.GetUserByID
func (mmGetUserByID *mUserStorageMockGetUserByID) Return(r1 user.Record, err error) *UserStorageMock {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("UserStorageMock.GetUserByID mock is already set by Set")
	}

	if mmGetUserByID.defaultExpectation == nil {
		mmGetUserByID.defaultExpectation = &UserStorageMockGetUserByIDExpectation{mock: mmGetUserByID.mock}
	}
	mmGetUserByID.defaultExpectation.results = &UserStorageMockGetUserByIDResults{r1, err}
	return mmGetUserByID.mock
}

// Set uses given function f to mock the userStorage.GetUserByID method
func (mmGetUserByID *mUserStorageMockGetUserByID) Set(f func(userID int64) (r1 user.Record, err error)) *UserStorageMock {
	if mmGetUserByID.defaultExpectation != nil {
		mmGetUserByID.mock.t.Fatalf("Default expectation is already set for the userStorage.GetUserByID method")
	}

	if len(mmGetUserByID.expectations) > 0 {
		mmGetUserByID.mock.t.Fatalf("Some expectations are already set for the userStorage.GetUserByID method")
	}

	mmGetUserByID.mock.funcGetUserByID = f
	return mmGetUserByID.mock
}

// When sets expectation for the userStorage.GetUserByID which will trigger the result defined by the following
// Then helper
func (mmGetUserByID *mUserStorageMockGetUserByID) When(userID int64) *UserStorageMockGetUserByIDExpectation {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("UserStorageMock.GetUserByID mock is already set by Set")
	}

	expectation := &UserStorageMockGetUserByIDExpectation{
		mock:   mmGetUserByID.mock,
		params: &UserStorageMockGetUserByIDParams{userID},
	}
	mmGetUserByID.expectations = append(mmGetUserByID.expectations, expectation)
	return expectation
}

// Then sets up userStorage.GetUserByID return parameters for the expectation previously defined by the When method
func (e *UserStorageMockGetUserByIDExpectation) Then(r1 user.Record, err error) *UserStorageMock {
	e.results = &UserStorageMockGetUserByIDResults{r1, err}
	return e.mock
}

// GetUserByID implements messages.userStorage
func (mmGetUserByID *UserStorageMock) GetUserByID(userID int64) (r1 user.Record, err error) {
	mm_atomic.AddUint64(&mmGetUserByID.beforeGetUserByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserByID.afterGetUserByIDCounter, 1)

	if mmGetUserByID.inspectFuncGetUserByID != nil {
		mmGetUserByID.inspectFuncGetUserByID(userID)
	}

	mm_params := &UserStorageMockGetUserByIDParams{userID}

	// Record call args
	mmGetUserByID.GetUserByIDMock.mutex.Lock()
	mmGetUserByID.GetUserByIDMock.callArgs = append(mmGetUserByID.GetUserByIDMock.callArgs, mm_params)
	mmGetUserByID.GetUserByIDMock.mutex.Unlock()

	for _, e := range mmGetUserByID.GetUserByIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmGetUserByID.GetUserByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserByID.GetUserByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserByID.GetUserByIDMock.defaultExpectation.params
		mm_got := UserStorageMockGetUserByIDParams{userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserByID.t.Errorf("UserStorageMock.GetUserByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserByID.GetUserByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserByID.t.Fatal("No results are set for the UserStorageMock.GetUserByID")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmGetUserByID.funcGetUserByID != nil {
		return mmGetUserByID.funcGetUserByID(userID)
	}
	mmGetUserByID.t.Fatalf("Unexpected call to UserStorageMock.GetUserByID. %v", userID)
	return
}

// GetUserByIDAfterCounter returns a count of finished UserStorageMock.GetUserByID invocations
func (mmGetUserByID *UserStorageMock) GetUserByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByID.afterGetUserByIDCounter)
}

// GetUserByIDBeforeCounter returns a count of UserStorageMock.GetUserByID invocations
func (mmGetUserByID *UserStorageMock) GetUserByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByID.beforeGetUserByIDCounter)
}

// Calls returns a list of arguments used in each call to UserStorageMock.GetUserByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserByID *mUserStorageMockGetUserByID) Calls() []*UserStorageMockGetUserByIDParams {
	mmGetUserByID.mutex.RLock()

	argCopy := make([]*UserStorageMockGetUserByIDParams, len(mmGetUserByID.callArgs))
	copy(argCopy, mmGetUserByID.callArgs)

	mmGetUserByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserByIDDone returns true if the count of the GetUserByID invocations corresponds
// the number of defined expectations
func (m *UserStorageMock) MinimockGetUserByIDDone() bool {
	for _, e := range m.GetUserByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserByIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserByID != nil && mm_atomic.LoadUint64(&m.afterGetUserByIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetUserByIDInspect logs each unmet expectation
func (m *UserStorageMock) MinimockGetUserByIDInspect() {
	for _, e := range m.GetUserByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserStorageMock.GetUserByID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserByIDCounter) < 1 {
		if m.GetUserByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserStorageMock.GetUserByID")
		} else {
			m.t.Errorf("Expected call to UserStorageMock.GetUserByID with params: %#v", *m.GetUserByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserByID != nil && mm_atomic.LoadUint64(&m.afterGetUserByIDCounter) < 1 {
		m.t.Error("Expected call to UserStorageMock.GetUserByID")
	}
}

type mUserStorageMockSaveUserByID struct {
	mock               *UserStorageMock
	defaultExpectation *UserStorageMockSaveUserByIDExpectation
	expectations       []*UserStorageMockSaveUserByIDExpectation

	callArgs []*UserStorageMockSaveUserByIDParams
	mutex    sync.RWMutex
}

// UserStorageMockSaveUserByIDExpectation specifies expectation struct of the userStorage.SaveUserByID
type UserStorageMockSaveUserByIDExpectation struct {
	mock    *UserStorageMock
	params  *UserStorageMockSaveUserByIDParams
	results *UserStorageMockSaveUserByIDResults
	Counter uint64
}

// UserStorageMockSaveUserByIDParams contains parameters of the userStorage.SaveUserByID
type UserStorageMockSaveUserByIDParams struct {
	userID int64
	rec    user.Record
}

// UserStorageMockSaveUserByIDResults contains results of the userStorage.SaveUserByID
type UserStorageMockSaveUserByIDResults struct {
	err error
}

// Expect sets up expected params for userStorage.SaveUserByID
func (mmSaveUserByID *mUserStorageMockSaveUserByID) Expect(userID int64, rec user.Record) *mUserStorageMockSaveUserByID {
	if mmSaveUserByID.mock.funcSaveUserByID != nil {
		mmSaveUserByID.mock.t.Fatalf("UserStorageMock.SaveUserByID mock is already set by Set")
	}

	if mmSaveUserByID.defaultExpectation == nil {
		mmSaveUserByID.defaultExpectation = &UserStorageMockSaveUserByIDExpectation{}
	}

	mmSaveUserByID.defaultExpectation.params = &UserStorageMockSaveUserByIDParams{userID, rec}
	for _, e := range mmSaveUserByID.expectations {
		if minimock.Equal(e.params, mmSaveUserByID.defaultExpectation.params) {
			mmSaveUserByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveUserByID.defaultExpectation.params)
		}
	}

	return mmSaveUserByID
}

// Inspect accepts an inspector function that has same arguments as the userStorage.SaveUserByID
func (mmSaveUserByID *mUserStorageMockSaveUserByID) Inspect(f func(userID int64, rec user.Record)) *mUserStorageMockSaveUserByID {
	if mmSaveUserByID.mock.inspectFuncSaveUserByID != nil {
		mmSaveUserByID.mock.t.Fatalf("Inspect function is already set for UserStorageMock.SaveUserByID")
	}

	mmSaveUserByID.mock.inspectFuncSaveUserByID = f

	return mmSaveUserByID
}

// Return sets up results that will be returned by userStorage.SaveUserByID
func (mmSaveUserByID *mUserStorageMockSaveUserByID) Return(err error) *UserStorageMock {
	if mmSaveUserByID.mock.funcSaveUserByID != nil {
		mmSaveUserByID.mock.t.Fatalf("UserStorageMock.SaveUserByID mock is already set by Set")
	}

	if mmSaveUserByID.defaultExpectation == nil {
		mmSaveUserByID.defaultExpectation = &UserStorageMockSaveUserByIDExpectation{mock: mmSaveUserByID.mock}
	}
	mmSaveUserByID.defaultExpectation.results = &UserStorageMockSaveUserByIDResults{err}
	return mmSaveUserByID.mock
}

// Set uses given function f to mock the userStorage.SaveUserByID method
func (mmSaveUserByID *mUserStorageMockSaveUserByID) Set(f func(userID int64, rec user.Record) (err error)) *UserStorageMock {
	if mmSaveUserByID.defaultExpectation != nil {
		mmSaveUserByID.mock.t.Fatalf("Default expectation is already set for the userStorage.SaveUserByID method")
	}

	if len(mmSaveUserByID.expectations) > 0 {
		mmSaveUserByID.mock.t.Fatalf("Some expectations are already set for the userStorage.SaveUserByID method")
	}

	mmSaveUserByID.mock.funcSaveUserByID = f
	return mmSaveUserByID.mock
}

// When sets expectation for the userStorage.SaveUserByID which will trigger the result defined by the following
// Then helper
func (mmSaveUserByID *mUserStorageMockSaveUserByID) When(userID int64, rec user.Record) *UserStorageMockSaveUserByIDExpectation {
	if mmSaveUserByID.mock.funcSaveUserByID != nil {
		mmSaveUserByID.mock.t.Fatalf("UserStorageMock.SaveUserByID mock is already set by Set")
	}

	expectation := &UserStorageMockSaveUserByIDExpectation{
		mock:   mmSaveUserByID.mock,
		params: &UserStorageMockSaveUserByIDParams{userID, rec},
	}
	mmSaveUserByID.expectations = append(mmSaveUserByID.expectations, expectation)
	return expectation
}

// Then sets up userStorage.SaveUserByID return parameters for the expectation previously defined by the When method
func (e *UserStorageMockSaveUserByIDExpectation) Then(err error) *UserStorageMock {
	e.results = &UserStorageMockSaveUserByIDResults{err}
	return e.mock
}

// SaveUserByID implements messages.userStorage
func (mmSaveUserByID *UserStorageMock) SaveUserByID(userID int64, rec user.Record) (err error) {
	mm_atomic.AddUint64(&mmSaveUserByID.beforeSaveUserByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveUserByID.afterSaveUserByIDCounter, 1)

	if mmSaveUserByID.inspectFuncSaveUserByID != nil {
		mmSaveUserByID.inspectFuncSaveUserByID(userID, rec)
	}

	mm_params := &UserStorageMockSaveUserByIDParams{userID, rec}

	// Record call args
	mmSaveUserByID.SaveUserByIDMock.mutex.Lock()
	mmSaveUserByID.SaveUserByIDMock.callArgs = append(mmSaveUserByID.SaveUserByIDMock.callArgs, mm_params)
	mmSaveUserByID.SaveUserByIDMock.mutex.Unlock()

	for _, e := range mmSaveUserByID.SaveUserByIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSaveUserByID.SaveUserByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveUserByID.SaveUserByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveUserByID.SaveUserByIDMock.defaultExpectation.params
		mm_got := UserStorageMockSaveUserByIDParams{userID, rec}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveUserByID.t.Errorf("UserStorageMock.SaveUserByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveUserByID.SaveUserByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveUserByID.t.Fatal("No results are set for the UserStorageMock.SaveUserByID")
		}
		return (*mm_results).err
	}
	if mmSaveUserByID.funcSaveUserByID != nil {
		return mmSaveUserByID.funcSaveUserByID(userID, rec)
	}
	mmSaveUserByID.t.Fatalf("Unexpected call to UserStorageMock.SaveUserByID. %v %v", userID, rec)
	return
}

// SaveUserByIDAfterCounter returns a count of finished UserStorageMock.SaveUserByID invocations
func (mmSaveUserByID *UserStorageMock) SaveUserByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveUserByID.afterSaveUserByIDCounter)
}

// SaveUserByIDBeforeCounter returns a count of UserStorageMock.SaveUserByID invocations
func (mmSaveUserByID *UserStorageMock) SaveUserByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveUserByID.beforeSaveUserByIDCounter)
}

// Calls returns a list of arguments used in each call to UserStorageMock.SaveUserByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveUserByID *mUserStorageMockSaveUserByID) Calls() []*UserStorageMockSaveUserByIDParams {
	mmSaveUserByID.mutex.RLock()

	argCopy := make([]*UserStorageMockSaveUserByIDParams, len(mmSaveUserByID.callArgs))
	copy(argCopy, mmSaveUserByID.callArgs)

	mmSaveUserByID.mutex.RUnlock()

	return argCopy
}

// MinimockSaveUserByIDDone returns true if the count of the SaveUserByID invocations corresponds
// the number of defined expectations
func (m *UserStorageMock) MinimockSaveUserByIDDone() bool {
	for _, e := range m.SaveUserByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveUserByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveUserByIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveUserByID != nil && mm_atomic.LoadUint64(&m.afterSaveUserByIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockSaveUserByIDInspect logs each unmet expectation
func (m *UserStorageMock) MinimockSaveUserByIDInspect() {
	for _, e := range m.SaveUserByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserStorageMock.SaveUserByID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveUserByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveUserByIDCounter) < 1 {
		if m.SaveUserByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserStorageMock.SaveUserByID")
		} else {
			m.t.Errorf("Expected call to UserStorageMock.SaveUserByID with params: %#v", *m.SaveUserByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveUserByID != nil && mm_atomic.LoadUint64(&m.afterSaveUserByIDCounter) < 1 {
		m.t.Error("Expected call to UserStorageMock.SaveUserByID")
	}
}

type mUserStorageMockSetCurrencyForUser struct {
	mock               *UserStorageMock
	defaultExpectation *UserStorageMockSetCurrencyForUserExpectation
	expectations       []*UserStorageMockSetCurrencyForUserExpectation

	callArgs []*UserStorageMockSetCurrencyForUserParams
	mutex    sync.RWMutex
}

// UserStorageMockSetCurrencyForUserExpectation specifies expectation struct of the userStorage.SetCurrencyForUser
type UserStorageMockSetCurrencyForUserExpectation struct {
	mock    *UserStorageMock
	params  *UserStorageMockSetCurrencyForUserParams
	results *UserStorageMockSetCurrencyForUserResults
	Counter uint64
}

// UserStorageMockSetCurrencyForUserParams contains parameters of the userStorage.SetCurrencyForUser
type UserStorageMockSetCurrencyForUserParams struct {
	userID int64
	curr   string
}

// UserStorageMockSetCurrencyForUserResults contains results of the userStorage.SetCurrencyForUser
type UserStorageMockSetCurrencyForUserResults struct {
	err error
}

// Expect sets up expected params for userStorage.SetCurrencyForUser
func (mmSetCurrencyForUser *mUserStorageMockSetCurrencyForUser) Expect(userID int64, curr string) *mUserStorageMockSetCurrencyForUser {
	if mmSetCurrencyForUser.mock.funcSetCurrencyForUser != nil {
		mmSetCurrencyForUser.mock.t.Fatalf("UserStorageMock.SetCurrencyForUser mock is already set by Set")
	}

	if mmSetCurrencyForUser.defaultExpectation == nil {
		mmSetCurrencyForUser.defaultExpectation = &UserStorageMockSetCurrencyForUserExpectation{}
	}

	mmSetCurrencyForUser.defaultExpectation.params = &UserStorageMockSetCurrencyForUserParams{userID, curr}
	for _, e := range mmSetCurrencyForUser.expectations {
		if minimock.Equal(e.params, mmSetCurrencyForUser.defaultExpectation.params) {
			mmSetCurrencyForUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetCurrencyForUser.defaultExpectation.params)
		}
	}

	return mmSetCurrencyForUser
}

// Inspect accepts an inspector function that has same arguments as the userStorage.SetCurrencyForUser
func (mmSetCurrencyForUser *mUserStorageMockSetCurrencyForUser) Inspect(f func(userID int64, curr string)) *mUserStorageMockSetCurrencyForUser {
	if mmSetCurrencyForUser.mock.inspectFuncSetCurrencyForUser != nil {
		mmSetCurrencyForUser.mock.t.Fatalf("Inspect function is already set for UserStorageMock.SetCurrencyForUser")
	}

	mmSetCurrencyForUser.mock.inspectFuncSetCurrencyForUser = f

	return mmSetCurrencyForUser
}

// Return sets up results that will be returned by userStorage.SetCurrencyForUser
func (mmSetCurrencyForUser *mUserStorageMockSetCurrencyForUser) Return(err error) *UserStorageMock {
	if mmSetCurrencyForUser.mock.funcSetCurrencyForUser != nil {
		mmSetCurrencyForUser.mock.t.Fatalf("UserStorageMock.SetCurrencyForUser mock is already set by Set")
	}

	if mmSetCurrencyForUser.defaultExpectation == nil {
		mmSetCurrencyForUser.defaultExpectation = &UserStorageMockSetCurrencyForUserExpectation{mock: mmSetCurrencyForUser.mock}
	}
	mmSetCurrencyForUser.defaultExpectation.results = &UserStorageMockSetCurrencyForUserResults{err}
	return mmSetCurrencyForUser.mock
}

// Set uses given function f to mock the userStorage.SetCurrencyForUser method
func (mmSetCurrencyForUser *mUserStorageMockSetCurrencyForUser) Set(f func(userID int64, curr string) (err error)) *UserStorageMock {
	if mmSetCurrencyForUser.defaultExpectation != nil {
		mmSetCurrencyForUser.mock.t.Fatalf("Default expectation is already set for the userStorage.SetCurrencyForUser method")
	}

	if len(mmSetCurrencyForUser.expectations) > 0 {
		mmSetCurrencyForUser.mock.t.Fatalf("Some expectations are already set for the userStorage.SetCurrencyForUser method")
	}

	mmSetCurrencyForUser.mock.funcSetCurrencyForUser = f
	return mmSetCurrencyForUser.mock
}

// When sets expectation for the userStorage.SetCurrencyForUser which will trigger the result defined by the following
// Then helper
func (mmSetCurrencyForUser *mUserStorageMockSetCurrencyForUser) When(userID int64, curr string) *UserStorageMockSetCurrencyForUserExpectation {
	if mmSetCurrencyForUser.mock.funcSetCurrencyForUser != nil {
		mmSetCurrencyForUser.mock.t.Fatalf("UserStorageMock.SetCurrencyForUser mock is already set by Set")
	}

	expectation := &UserStorageMockSetCurrencyForUserExpectation{
		mock:   mmSetCurrencyForUser.mock,
		params: &UserStorageMockSetCurrencyForUserParams{userID, curr},
	}
	mmSetCurrencyForUser.expectations = append(mmSetCurrencyForUser.expectations, expectation)
	return expectation
}

// Then sets up userStorage.SetCurrencyForUser return parameters for the expectation previously defined by the When method
func (e *UserStorageMockSetCurrencyForUserExpectation) Then(err error) *UserStorageMock {
	e.results = &UserStorageMockSetCurrencyForUserResults{err}
	return e.mock
}

// SetCurrencyForUser implements messages.userStorage
func (mmSetCurrencyForUser *UserStorageMock) SetCurrencyForUser(userID int64, curr string) (err error) {
	mm_atomic.AddUint64(&mmSetCurrencyForUser.beforeSetCurrencyForUserCounter, 1)
	defer mm_atomic.AddUint64(&mmSetCurrencyForUser.afterSetCurrencyForUserCounter, 1)

	if mmSetCurrencyForUser.inspectFuncSetCurrencyForUser != nil {
		mmSetCurrencyForUser.inspectFuncSetCurrencyForUser(userID, curr)
	}

	mm_params := &UserStorageMockSetCurrencyForUserParams{userID, curr}

	// Record call args
	mmSetCurrencyForUser.SetCurrencyForUserMock.mutex.Lock()
	mmSetCurrencyForUser.SetCurrencyForUserMock.callArgs = append(mmSetCurrencyForUser.SetCurrencyForUserMock.callArgs, mm_params)
	mmSetCurrencyForUser.SetCurrencyForUserMock.mutex.Unlock()

	for _, e := range mmSetCurrencyForUser.SetCurrencyForUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetCurrencyForUser.SetCurrencyForUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetCurrencyForUser.SetCurrencyForUserMock.defaultExpectation.Counter, 1)
		mm_want := mmSetCurrencyForUser.SetCurrencyForUserMock.defaultExpectation.params
		mm_got := UserStorageMockSetCurrencyForUserParams{userID, curr}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetCurrencyForUser.t.Errorf("UserStorageMock.SetCurrencyForUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetCurrencyForUser.SetCurrencyForUserMock.defaultExpectation.results
		if mm_results == nil {
			mmSetCurrencyForUser.t.Fatal("No results are set for the UserStorageMock.SetCurrencyForUser")
		}
		return (*mm_results).err
	}
	if mmSetCurrencyForUser.funcSetCurrencyForUser != nil {
		return mmSetCurrencyForUser.funcSetCurrencyForUser(userID, curr)
	}
	mmSetCurrencyForUser.t.Fatalf("Unexpected call to UserStorageMock.SetCurrencyForUser. %v %v", userID, curr)
	return
}

// SetCurrencyForUserAfterCounter returns a count of finished UserStorageMock.SetCurrencyForUser invocations
func (mmSetCurrencyForUser *UserStorageMock) SetCurrencyForUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetCurrencyForUser.afterSetCurrencyForUserCounter)
}

// SetCurrencyForUserBeforeCounter returns a count of UserStorageMock.SetCurrencyForUser invocations
func (mmSetCurrencyForUser *UserStorageMock) SetCurrencyForUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetCurrencyForUser.beforeSetCurrencyForUserCounter)
}

// Calls returns a list of arguments used in each call to UserStorageMock.SetCurrencyForUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetCurrencyForUser *mUserStorageMockSetCurrencyForUser) Calls() []*UserStorageMockSetCurrencyForUserParams {
	mmSetCurrencyForUser.mutex.RLock()

	argCopy := make([]*UserStorageMockSetCurrencyForUserParams, len(mmSetCurrencyForUser.callArgs))
	copy(argCopy, mmSetCurrencyForUser.callArgs)

	mmSetCurrencyForUser.mutex.RUnlock()

	return argCopy
}

// MinimockSetCurrencyForUserDone returns true if the count of the SetCurrencyForUser invocations corresponds
// the number of defined expectations
func (m *UserStorageMock) MinimockSetCurrencyForUserDone() bool {
	for _, e := range m.SetCurrencyForUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetCurrencyForUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetCurrencyForUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetCurrencyForUser != nil && mm_atomic.LoadUint64(&m.afterSetCurrencyForUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetCurrencyForUserInspect logs each unmet expectation
func (m *UserStorageMock) MinimockSetCurrencyForUserInspect() {
	for _, e := range m.SetCurrencyForUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserStorageMock.SetCurrencyForUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetCurrencyForUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetCurrencyForUserCounter) < 1 {
		if m.SetCurrencyForUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserStorageMock.SetCurrencyForUser")
		} else {
			m.t.Errorf("Expected call to UserStorageMock.SetCurrencyForUser with params: %#v", *m.SetCurrencyForUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetCurrencyForUser != nil && mm_atomic.LoadUint64(&m.afterSetCurrencyForUserCounter) < 1 {
		m.t.Error("Expected call to UserStorageMock.SetCurrencyForUser")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserStorageMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetRateInspect()

		m.MinimockGetUserByIDInspect()

		m.MinimockSaveUserByIDInspect()

		m.MinimockSetCurrencyForUserInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserStorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserStorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetRateDone() &&
		m.MinimockGetUserByIDDone() &&
		m.MinimockSaveUserByIDDone() &&
		m.MinimockSetCurrencyForUserDone()
}
