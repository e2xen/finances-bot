package mock

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i max.ks1230/finances-bot/internal/model/messages.userStorage -o ./mock/user_storage_mock.go -n UserStorageMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"max.ks1230/finances-bot/internal/entity/currency"
	"max.ks1230/finances-bot/internal/entity/user"
)

// UserStorageMock implements messages.userStorage
type UserStorageMock struct {
	t minimock.Tester

	funcGetRate          func(ctx context.Context, name string) (r1 currency.Rate, err error)
	inspectFuncGetRate   func(ctx context.Context, name string)
	afterGetRateCounter  uint64
	beforeGetRateCounter uint64
	GetRateMock          mUserStorageMockGetRate

	funcGetUserByID          func(ctx context.Context, userID int64) (r1 user.Record, err error)
	inspectFuncGetUserByID   func(ctx context.Context, userID int64)
	afterGetUserByIDCounter  uint64
	beforeGetUserByIDCounter uint64
	GetUserByIDMock          mUserStorageMockGetUserByID

	funcSaveExpense          func(ctx context.Context, userID int64, record user.ExpenseRecord) (err error)
	inspectFuncSaveExpense   func(ctx context.Context, userID int64, record user.ExpenseRecord)
	afterSaveExpenseCounter  uint64
	beforeSaveExpenseCounter uint64
	SaveExpenseMock          mUserStorageMockSaveExpense

	funcSaveUserByID          func(ctx context.Context, userID int64, rec user.Record) (err error)
	inspectFuncSaveUserByID   func(ctx context.Context, userID int64, rec user.Record)
	afterSaveUserByIDCounter  uint64
	beforeSaveUserByIDCounter uint64
	SaveUserByIDMock          mUserStorageMockSaveUserByID
}

// NewUserStorageMock returns a mock for messages.userStorage
func NewUserStorageMock(t minimock.Tester) *UserStorageMock {
	m := &UserStorageMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetRateMock = mUserStorageMockGetRate{mock: m}
	m.GetRateMock.callArgs = []*UserStorageMockGetRateParams{}

	m.GetUserByIDMock = mUserStorageMockGetUserByID{mock: m}
	m.GetUserByIDMock.callArgs = []*UserStorageMockGetUserByIDParams{}

	m.SaveExpenseMock = mUserStorageMockSaveExpense{mock: m}
	m.SaveExpenseMock.callArgs = []*UserStorageMockSaveExpenseParams{}

	m.SaveUserByIDMock = mUserStorageMockSaveUserByID{mock: m}
	m.SaveUserByIDMock.callArgs = []*UserStorageMockSaveUserByIDParams{}

	return m
}

type mUserStorageMockGetRate struct {
	mock               *UserStorageMock
	defaultExpectation *UserStorageMockGetRateExpectation
	expectations       []*UserStorageMockGetRateExpectation

	callArgs []*UserStorageMockGetRateParams
	mutex    sync.RWMutex
}

// UserStorageMockGetRateExpectation specifies expectation struct of the userStorage.GetRate
type UserStorageMockGetRateExpectation struct {
	mock    *UserStorageMock
	params  *UserStorageMockGetRateParams
	results *UserStorageMockGetRateResults
	Counter uint64
}

// UserStorageMockGetRateParams contains parameters of the userStorage.GetRate
type UserStorageMockGetRateParams struct {
	ctx  context.Context
	name string
}

// UserStorageMockGetRateResults contains results of the userStorage.GetRate
type UserStorageMockGetRateResults struct {
	r1  currency.Rate
	err error
}

// Expect sets up expected params for userStorage.GetRate
func (mmGetRate *mUserStorageMockGetRate) Expect(ctx context.Context, name string) *mUserStorageMockGetRate {
	if mmGetRate.mock.funcGetRate != nil {
		mmGetRate.mock.t.Fatalf("UserStorageMock.GetRate mock is already set by Set")
	}

	if mmGetRate.defaultExpectation == nil {
		mmGetRate.defaultExpectation = &UserStorageMockGetRateExpectation{}
	}

	mmGetRate.defaultExpectation.params = &UserStorageMockGetRateParams{ctx, name}
	for _, e := range mmGetRate.expectations {
		if minimock.Equal(e.params, mmGetRate.defaultExpectation.params) {
			mmGetRate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRate.defaultExpectation.params)
		}
	}

	return mmGetRate
}

// Inspect accepts an inspector function that has same arguments as the userStorage.GetRate
func (mmGetRate *mUserStorageMockGetRate) Inspect(f func(ctx context.Context, name string)) *mUserStorageMockGetRate {
	if mmGetRate.mock.inspectFuncGetRate != nil {
		mmGetRate.mock.t.Fatalf("Inspect function is already set for UserStorageMock.GetRate")
	}

	mmGetRate.mock.inspectFuncGetRate = f

	return mmGetRate
}

// Return sets up results that will be returned by userStorage.GetRate
func (mmGetRate *mUserStorageMockGetRate) Return(r1 currency.Rate, err error) *UserStorageMock {
	if mmGetRate.mock.funcGetRate != nil {
		mmGetRate.mock.t.Fatalf("UserStorageMock.GetRate mock is already set by Set")
	}

	if mmGetRate.defaultExpectation == nil {
		mmGetRate.defaultExpectation = &UserStorageMockGetRateExpectation{mock: mmGetRate.mock}
	}
	mmGetRate.defaultExpectation.results = &UserStorageMockGetRateResults{r1, err}
	return mmGetRate.mock
}

// Set uses given function f to mock the userStorage.GetRate method
func (mmGetRate *mUserStorageMockGetRate) Set(f func(ctx context.Context, name string) (r1 currency.Rate, err error)) *UserStorageMock {
	if mmGetRate.defaultExpectation != nil {
		mmGetRate.mock.t.Fatalf("Default expectation is already set for the userStorage.GetRate method")
	}

	if len(mmGetRate.expectations) > 0 {
		mmGetRate.mock.t.Fatalf("Some expectations are already set for the userStorage.GetRate method")
	}

	mmGetRate.mock.funcGetRate = f
	return mmGetRate.mock
}

// When sets expectation for the userStorage.GetRate which will trigger the result defined by the following
// Then helper
func (mmGetRate *mUserStorageMockGetRate) When(ctx context.Context, name string) *UserStorageMockGetRateExpectation {
	if mmGetRate.mock.funcGetRate != nil {
		mmGetRate.mock.t.Fatalf("UserStorageMock.GetRate mock is already set by Set")
	}

	expectation := &UserStorageMockGetRateExpectation{
		mock:   mmGetRate.mock,
		params: &UserStorageMockGetRateParams{ctx, name},
	}
	mmGetRate.expectations = append(mmGetRate.expectations, expectation)
	return expectation
}

// Then sets up userStorage.GetRate return parameters for the expectation previously defined by the When method
func (e *UserStorageMockGetRateExpectation) Then(r1 currency.Rate, err error) *UserStorageMock {
	e.results = &UserStorageMockGetRateResults{r1, err}
	return e.mock
}

// GetRate implements messages.userStorage
func (mmGetRate *UserStorageMock) GetRate(ctx context.Context, name string) (r1 currency.Rate, err error) {
	mm_atomic.AddUint64(&mmGetRate.beforeGetRateCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRate.afterGetRateCounter, 1)

	if mmGetRate.inspectFuncGetRate != nil {
		mmGetRate.inspectFuncGetRate(ctx, name)
	}

	mm_params := &UserStorageMockGetRateParams{ctx, name}

	// Record call args
	mmGetRate.GetRateMock.mutex.Lock()
	mmGetRate.GetRateMock.callArgs = append(mmGetRate.GetRateMock.callArgs, mm_params)
	mmGetRate.GetRateMock.mutex.Unlock()

	for _, e := range mmGetRate.GetRateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmGetRate.GetRateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRate.GetRateMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRate.GetRateMock.defaultExpectation.params
		mm_got := UserStorageMockGetRateParams{ctx, name}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRate.t.Errorf("UserStorageMock.GetRate got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRate.GetRateMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRate.t.Fatal("No results are set for the UserStorageMock.GetRate")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmGetRate.funcGetRate != nil {
		return mmGetRate.funcGetRate(ctx, name)
	}
	mmGetRate.t.Fatalf("Unexpected call to UserStorageMock.GetRate. %v %v", ctx, name)
	return
}

// GetRateAfterCounter returns a count of finished UserStorageMock.GetRate invocations
func (mmGetRate *UserStorageMock) GetRateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRate.afterGetRateCounter)
}

// GetRateBeforeCounter returns a count of UserStorageMock.GetRate invocations
func (mmGetRate *UserStorageMock) GetRateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRate.beforeGetRateCounter)
}

// Calls returns a list of arguments used in each call to UserStorageMock.GetRate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRate *mUserStorageMockGetRate) Calls() []*UserStorageMockGetRateParams {
	mmGetRate.mutex.RLock()

	argCopy := make([]*UserStorageMockGetRateParams, len(mmGetRate.callArgs))
	copy(argCopy, mmGetRate.callArgs)

	mmGetRate.mutex.RUnlock()

	return argCopy
}

// MinimockGetRateDone returns true if the count of the GetRate invocations corresponds
// the number of defined expectations
func (m *UserStorageMock) MinimockGetRateDone() bool {
	for _, e := range m.GetRateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRate != nil && mm_atomic.LoadUint64(&m.afterGetRateCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetRateInspect logs each unmet expectation
func (m *UserStorageMock) MinimockGetRateInspect() {
	for _, e := range m.GetRateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserStorageMock.GetRate with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRateCounter) < 1 {
		if m.GetRateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserStorageMock.GetRate")
		} else {
			m.t.Errorf("Expected call to UserStorageMock.GetRate with params: %#v", *m.GetRateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRate != nil && mm_atomic.LoadUint64(&m.afterGetRateCounter) < 1 {
		m.t.Error("Expected call to UserStorageMock.GetRate")
	}
}

type mUserStorageMockGetUserByID struct {
	mock               *UserStorageMock
	defaultExpectation *UserStorageMockGetUserByIDExpectation
	expectations       []*UserStorageMockGetUserByIDExpectation

	callArgs []*UserStorageMockGetUserByIDParams
	mutex    sync.RWMutex
}

// UserStorageMockGetUserByIDExpectation specifies expectation struct of the userStorage.GetUserByID
type UserStorageMockGetUserByIDExpectation struct {
	mock    *UserStorageMock
	params  *UserStorageMockGetUserByIDParams
	results *UserStorageMockGetUserByIDResults
	Counter uint64
}

// UserStorageMockGetUserByIDParams contains parameters of the userStorage.GetUserByID
type UserStorageMockGetUserByIDParams struct {
	ctx    context.Context
	userID int64
}

// UserStorageMockGetUserByIDResults contains results of the userStorage.GetUserByID
type UserStorageMockGetUserByIDResults struct {
	r1  user.Record
	err error
}

// Expect sets up expected params for userStorage.GetUserByID
func (mmGetUserByID *mUserStorageMockGetUserByID) Expect(ctx context.Context, userID int64) *mUserStorageMockGetUserByID {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("UserStorageMock.GetUserByID mock is already set by Set")
	}

	if mmGetUserByID.defaultExpectation == nil {
		mmGetUserByID.defaultExpectation = &UserStorageMockGetUserByIDExpectation{}
	}

	mmGetUserByID.defaultExpectation.params = &UserStorageMockGetUserByIDParams{ctx, userID}
	for _, e := range mmGetUserByID.expectations {
		if minimock.Equal(e.params, mmGetUserByID.defaultExpectation.params) {
			mmGetUserByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserByID.defaultExpectation.params)
		}
	}

	return mmGetUserByID
}

// Inspect accepts an inspector function that has same arguments as the userStorage.GetUserByID
func (mmGetUserByID *mUserStorageMockGetUserByID) Inspect(f func(ctx context.Context, userID int64)) *mUserStorageMockGetUserByID {
	if mmGetUserByID.mock.inspectFuncGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("Inspect function is already set for UserStorageMock.GetUserByID")
	}

	mmGetUserByID.mock.inspectFuncGetUserByID = f

	return mmGetUserByID
}

// Return sets up results that will be returned by userStorage.GetUserByID
func (mmGetUserByID *mUserStorageMockGetUserByID) Return(r1 user.Record, err error) *UserStorageMock {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("UserStorageMock.GetUserByID mock is already set by Set")
	}

	if mmGetUserByID.defaultExpectation == nil {
		mmGetUserByID.defaultExpectation = &UserStorageMockGetUserByIDExpectation{mock: mmGetUserByID.mock}
	}
	mmGetUserByID.defaultExpectation.results = &UserStorageMockGetUserByIDResults{r1, err}
	return mmGetUserByID.mock
}

// Set uses given function f to mock the userStorage.GetUserByID method
func (mmGetUserByID *mUserStorageMockGetUserByID) Set(f func(ctx context.Context, userID int64) (r1 user.Record, err error)) *UserStorageMock {
	if mmGetUserByID.defaultExpectation != nil {
		mmGetUserByID.mock.t.Fatalf("Default expectation is already set for the userStorage.GetUserByID method")
	}

	if len(mmGetUserByID.expectations) > 0 {
		mmGetUserByID.mock.t.Fatalf("Some expectations are already set for the userStorage.GetUserByID method")
	}

	mmGetUserByID.mock.funcGetUserByID = f
	return mmGetUserByID.mock
}

// When sets expectation for the userStorage.GetUserByID which will trigger the result defined by the following
// Then helper
func (mmGetUserByID *mUserStorageMockGetUserByID) When(ctx context.Context, userID int64) *UserStorageMockGetUserByIDExpectation {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("UserStorageMock.GetUserByID mock is already set by Set")
	}

	expectation := &UserStorageMockGetUserByIDExpectation{
		mock:   mmGetUserByID.mock,
		params: &UserStorageMockGetUserByIDParams{ctx, userID},
	}
	mmGetUserByID.expectations = append(mmGetUserByID.expectations, expectation)
	return expectation
}

// Then sets up userStorage.GetUserByID return parameters for the expectation previously defined by the When method
func (e *UserStorageMockGetUserByIDExpectation) Then(r1 user.Record, err error) *UserStorageMock {
	e.results = &UserStorageMockGetUserByIDResults{r1, err}
	return e.mock
}

// GetUserByID implements messages.userStorage
func (mmGetUserByID *UserStorageMock) GetUserByID(ctx context.Context, userID int64) (r1 user.Record, err error) {
	mm_atomic.AddUint64(&mmGetUserByID.beforeGetUserByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserByID.afterGetUserByIDCounter, 1)

	if mmGetUserByID.inspectFuncGetUserByID != nil {
		mmGetUserByID.inspectFuncGetUserByID(ctx, userID)
	}

	mm_params := &UserStorageMockGetUserByIDParams{ctx, userID}

	// Record call args
	mmGetUserByID.GetUserByIDMock.mutex.Lock()
	mmGetUserByID.GetUserByIDMock.callArgs = append(mmGetUserByID.GetUserByIDMock.callArgs, mm_params)
	mmGetUserByID.GetUserByIDMock.mutex.Unlock()

	for _, e := range mmGetUserByID.GetUserByIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmGetUserByID.GetUserByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserByID.GetUserByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserByID.GetUserByIDMock.defaultExpectation.params
		mm_got := UserStorageMockGetUserByIDParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserByID.t.Errorf("UserStorageMock.GetUserByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserByID.GetUserByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserByID.t.Fatal("No results are set for the UserStorageMock.GetUserByID")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmGetUserByID.funcGetUserByID != nil {
		return mmGetUserByID.funcGetUserByID(ctx, userID)
	}
	mmGetUserByID.t.Fatalf("Unexpected call to UserStorageMock.GetUserByID. %v %v", ctx, userID)
	return
}

// GetUserByIDAfterCounter returns a count of finished UserStorageMock.GetUserByID invocations
func (mmGetUserByID *UserStorageMock) GetUserByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByID.afterGetUserByIDCounter)
}

// GetUserByIDBeforeCounter returns a count of UserStorageMock.GetUserByID invocations
func (mmGetUserByID *UserStorageMock) GetUserByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByID.beforeGetUserByIDCounter)
}

// Calls returns a list of arguments used in each call to UserStorageMock.GetUserByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserByID *mUserStorageMockGetUserByID) Calls() []*UserStorageMockGetUserByIDParams {
	mmGetUserByID.mutex.RLock()

	argCopy := make([]*UserStorageMockGetUserByIDParams, len(mmGetUserByID.callArgs))
	copy(argCopy, mmGetUserByID.callArgs)

	mmGetUserByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserByIDDone returns true if the count of the GetUserByID invocations corresponds
// the number of defined expectations
func (m *UserStorageMock) MinimockGetUserByIDDone() bool {
	for _, e := range m.GetUserByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserByIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserByID != nil && mm_atomic.LoadUint64(&m.afterGetUserByIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetUserByIDInspect logs each unmet expectation
func (m *UserStorageMock) MinimockGetUserByIDInspect() {
	for _, e := range m.GetUserByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserStorageMock.GetUserByID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserByIDCounter) < 1 {
		if m.GetUserByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserStorageMock.GetUserByID")
		} else {
			m.t.Errorf("Expected call to UserStorageMock.GetUserByID with params: %#v", *m.GetUserByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserByID != nil && mm_atomic.LoadUint64(&m.afterGetUserByIDCounter) < 1 {
		m.t.Error("Expected call to UserStorageMock.GetUserByID")
	}
}

type mUserStorageMockSaveExpense struct {
	mock               *UserStorageMock
	defaultExpectation *UserStorageMockSaveExpenseExpectation
	expectations       []*UserStorageMockSaveExpenseExpectation

	callArgs []*UserStorageMockSaveExpenseParams
	mutex    sync.RWMutex
}

// UserStorageMockSaveExpenseExpectation specifies expectation struct of the userStorage.SaveExpense
type UserStorageMockSaveExpenseExpectation struct {
	mock    *UserStorageMock
	params  *UserStorageMockSaveExpenseParams
	results *UserStorageMockSaveExpenseResults
	Counter uint64
}

// UserStorageMockSaveExpenseParams contains parameters of the userStorage.SaveExpense
type UserStorageMockSaveExpenseParams struct {
	ctx    context.Context
	userID int64
	record user.ExpenseRecord
}

// UserStorageMockSaveExpenseResults contains results of the userStorage.SaveExpense
type UserStorageMockSaveExpenseResults struct {
	err error
}

// Expect sets up expected params for userStorage.SaveExpense
func (mmSaveExpense *mUserStorageMockSaveExpense) Expect(ctx context.Context, userID int64, record user.ExpenseRecord) *mUserStorageMockSaveExpense {
	if mmSaveExpense.mock.funcSaveExpense != nil {
		mmSaveExpense.mock.t.Fatalf("UserStorageMock.SaveExpense mock is already set by Set")
	}

	if mmSaveExpense.defaultExpectation == nil {
		mmSaveExpense.defaultExpectation = &UserStorageMockSaveExpenseExpectation{}
	}

	mmSaveExpense.defaultExpectation.params = &UserStorageMockSaveExpenseParams{ctx, userID, record}
	for _, e := range mmSaveExpense.expectations {
		if minimock.Equal(e.params, mmSaveExpense.defaultExpectation.params) {
			mmSaveExpense.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveExpense.defaultExpectation.params)
		}
	}

	return mmSaveExpense
}

// Inspect accepts an inspector function that has same arguments as the userStorage.SaveExpense
func (mmSaveExpense *mUserStorageMockSaveExpense) Inspect(f func(ctx context.Context, userID int64, record user.ExpenseRecord)) *mUserStorageMockSaveExpense {
	if mmSaveExpense.mock.inspectFuncSaveExpense != nil {
		mmSaveExpense.mock.t.Fatalf("Inspect function is already set for UserStorageMock.SaveExpense")
	}

	mmSaveExpense.mock.inspectFuncSaveExpense = f

	return mmSaveExpense
}

// Return sets up results that will be returned by userStorage.SaveExpense
func (mmSaveExpense *mUserStorageMockSaveExpense) Return(err error) *UserStorageMock {
	if mmSaveExpense.mock.funcSaveExpense != nil {
		mmSaveExpense.mock.t.Fatalf("UserStorageMock.SaveExpense mock is already set by Set")
	}

	if mmSaveExpense.defaultExpectation == nil {
		mmSaveExpense.defaultExpectation = &UserStorageMockSaveExpenseExpectation{mock: mmSaveExpense.mock}
	}
	mmSaveExpense.defaultExpectation.results = &UserStorageMockSaveExpenseResults{err}
	return mmSaveExpense.mock
}

// Set uses given function f to mock the userStorage.SaveExpense method
func (mmSaveExpense *mUserStorageMockSaveExpense) Set(f func(ctx context.Context, userID int64, record user.ExpenseRecord) (err error)) *UserStorageMock {
	if mmSaveExpense.defaultExpectation != nil {
		mmSaveExpense.mock.t.Fatalf("Default expectation is already set for the userStorage.SaveExpense method")
	}

	if len(mmSaveExpense.expectations) > 0 {
		mmSaveExpense.mock.t.Fatalf("Some expectations are already set for the userStorage.SaveExpense method")
	}

	mmSaveExpense.mock.funcSaveExpense = f
	return mmSaveExpense.mock
}

// When sets expectation for the userStorage.SaveExpense which will trigger the result defined by the following
// Then helper
func (mmSaveExpense *mUserStorageMockSaveExpense) When(ctx context.Context, userID int64, record user.ExpenseRecord) *UserStorageMockSaveExpenseExpectation {
	if mmSaveExpense.mock.funcSaveExpense != nil {
		mmSaveExpense.mock.t.Fatalf("UserStorageMock.SaveExpense mock is already set by Set")
	}

	expectation := &UserStorageMockSaveExpenseExpectation{
		mock:   mmSaveExpense.mock,
		params: &UserStorageMockSaveExpenseParams{ctx, userID, record},
	}
	mmSaveExpense.expectations = append(mmSaveExpense.expectations, expectation)
	return expectation
}

// Then sets up userStorage.SaveExpense return parameters for the expectation previously defined by the When method
func (e *UserStorageMockSaveExpenseExpectation) Then(err error) *UserStorageMock {
	e.results = &UserStorageMockSaveExpenseResults{err}
	return e.mock
}

// SaveExpense implements messages.userStorage
func (mmSaveExpense *UserStorageMock) SaveExpense(ctx context.Context, userID int64, record user.ExpenseRecord) (err error) {
	mm_atomic.AddUint64(&mmSaveExpense.beforeSaveExpenseCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveExpense.afterSaveExpenseCounter, 1)

	if mmSaveExpense.inspectFuncSaveExpense != nil {
		mmSaveExpense.inspectFuncSaveExpense(ctx, userID, record)
	}

	mm_params := &UserStorageMockSaveExpenseParams{ctx, userID, record}

	// Record call args
	mmSaveExpense.SaveExpenseMock.mutex.Lock()
	mmSaveExpense.SaveExpenseMock.callArgs = append(mmSaveExpense.SaveExpenseMock.callArgs, mm_params)
	mmSaveExpense.SaveExpenseMock.mutex.Unlock()

	for _, e := range mmSaveExpense.SaveExpenseMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSaveExpense.SaveExpenseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveExpense.SaveExpenseMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveExpense.SaveExpenseMock.defaultExpectation.params
		mm_got := UserStorageMockSaveExpenseParams{ctx, userID, record}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveExpense.t.Errorf("UserStorageMock.SaveExpense got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveExpense.SaveExpenseMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveExpense.t.Fatal("No results are set for the UserStorageMock.SaveExpense")
		}
		return (*mm_results).err
	}
	if mmSaveExpense.funcSaveExpense != nil {
		return mmSaveExpense.funcSaveExpense(ctx, userID, record)
	}
	mmSaveExpense.t.Fatalf("Unexpected call to UserStorageMock.SaveExpense. %v %v %v", ctx, userID, record)
	return
}

// SaveExpenseAfterCounter returns a count of finished UserStorageMock.SaveExpense invocations
func (mmSaveExpense *UserStorageMock) SaveExpenseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveExpense.afterSaveExpenseCounter)
}

// SaveExpenseBeforeCounter returns a count of UserStorageMock.SaveExpense invocations
func (mmSaveExpense *UserStorageMock) SaveExpenseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveExpense.beforeSaveExpenseCounter)
}

// Calls returns a list of arguments used in each call to UserStorageMock.SaveExpense.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveExpense *mUserStorageMockSaveExpense) Calls() []*UserStorageMockSaveExpenseParams {
	mmSaveExpense.mutex.RLock()

	argCopy := make([]*UserStorageMockSaveExpenseParams, len(mmSaveExpense.callArgs))
	copy(argCopy, mmSaveExpense.callArgs)

	mmSaveExpense.mutex.RUnlock()

	return argCopy
}

// MinimockSaveExpenseDone returns true if the count of the SaveExpense invocations corresponds
// the number of defined expectations
func (m *UserStorageMock) MinimockSaveExpenseDone() bool {
	for _, e := range m.SaveExpenseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveExpenseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveExpenseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveExpense != nil && mm_atomic.LoadUint64(&m.afterSaveExpenseCounter) < 1 {
		return false
	}
	return true
}

// MinimockSaveExpenseInspect logs each unmet expectation
func (m *UserStorageMock) MinimockSaveExpenseInspect() {
	for _, e := range m.SaveExpenseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserStorageMock.SaveExpense with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveExpenseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveExpenseCounter) < 1 {
		if m.SaveExpenseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserStorageMock.SaveExpense")
		} else {
			m.t.Errorf("Expected call to UserStorageMock.SaveExpense with params: %#v", *m.SaveExpenseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveExpense != nil && mm_atomic.LoadUint64(&m.afterSaveExpenseCounter) < 1 {
		m.t.Error("Expected call to UserStorageMock.SaveExpense")
	}
}

type mUserStorageMockSaveUserByID struct {
	mock               *UserStorageMock
	defaultExpectation *UserStorageMockSaveUserByIDExpectation
	expectations       []*UserStorageMockSaveUserByIDExpectation

	callArgs []*UserStorageMockSaveUserByIDParams
	mutex    sync.RWMutex
}

// UserStorageMockSaveUserByIDExpectation specifies expectation struct of the userStorage.SaveUserByID
type UserStorageMockSaveUserByIDExpectation struct {
	mock    *UserStorageMock
	params  *UserStorageMockSaveUserByIDParams
	results *UserStorageMockSaveUserByIDResults
	Counter uint64
}

// UserStorageMockSaveUserByIDParams contains parameters of the userStorage.SaveUserByID
type UserStorageMockSaveUserByIDParams struct {
	ctx    context.Context
	userID int64
	rec    user.Record
}

// UserStorageMockSaveUserByIDResults contains results of the userStorage.SaveUserByID
type UserStorageMockSaveUserByIDResults struct {
	err error
}

// Expect sets up expected params for userStorage.SaveUserByID
func (mmSaveUserByID *mUserStorageMockSaveUserByID) Expect(ctx context.Context, userID int64, rec user.Record) *mUserStorageMockSaveUserByID {
	if mmSaveUserByID.mock.funcSaveUserByID != nil {
		mmSaveUserByID.mock.t.Fatalf("UserStorageMock.SaveUserByID mock is already set by Set")
	}

	if mmSaveUserByID.defaultExpectation == nil {
		mmSaveUserByID.defaultExpectation = &UserStorageMockSaveUserByIDExpectation{}
	}

	mmSaveUserByID.defaultExpectation.params = &UserStorageMockSaveUserByIDParams{ctx, userID, rec}
	for _, e := range mmSaveUserByID.expectations {
		if minimock.Equal(e.params, mmSaveUserByID.defaultExpectation.params) {
			mmSaveUserByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveUserByID.defaultExpectation.params)
		}
	}

	return mmSaveUserByID
}

// Inspect accepts an inspector function that has same arguments as the userStorage.SaveUserByID
func (mmSaveUserByID *mUserStorageMockSaveUserByID) Inspect(f func(ctx context.Context, userID int64, rec user.Record)) *mUserStorageMockSaveUserByID {
	if mmSaveUserByID.mock.inspectFuncSaveUserByID != nil {
		mmSaveUserByID.mock.t.Fatalf("Inspect function is already set for UserStorageMock.SaveUserByID")
	}

	mmSaveUserByID.mock.inspectFuncSaveUserByID = f

	return mmSaveUserByID
}

// Return sets up results that will be returned by userStorage.SaveUserByID
func (mmSaveUserByID *mUserStorageMockSaveUserByID) Return(err error) *UserStorageMock {
	if mmSaveUserByID.mock.funcSaveUserByID != nil {
		mmSaveUserByID.mock.t.Fatalf("UserStorageMock.SaveUserByID mock is already set by Set")
	}

	if mmSaveUserByID.defaultExpectation == nil {
		mmSaveUserByID.defaultExpectation = &UserStorageMockSaveUserByIDExpectation{mock: mmSaveUserByID.mock}
	}
	mmSaveUserByID.defaultExpectation.results = &UserStorageMockSaveUserByIDResults{err}
	return mmSaveUserByID.mock
}

// Set uses given function f to mock the userStorage.SaveUserByID method
func (mmSaveUserByID *mUserStorageMockSaveUserByID) Set(f func(ctx context.Context, userID int64, rec user.Record) (err error)) *UserStorageMock {
	if mmSaveUserByID.defaultExpectation != nil {
		mmSaveUserByID.mock.t.Fatalf("Default expectation is already set for the userStorage.SaveUserByID method")
	}

	if len(mmSaveUserByID.expectations) > 0 {
		mmSaveUserByID.mock.t.Fatalf("Some expectations are already set for the userStorage.SaveUserByID method")
	}

	mmSaveUserByID.mock.funcSaveUserByID = f
	return mmSaveUserByID.mock
}

// When sets expectation for the userStorage.SaveUserByID which will trigger the result defined by the following
// Then helper
func (mmSaveUserByID *mUserStorageMockSaveUserByID) When(ctx context.Context, userID int64, rec user.Record) *UserStorageMockSaveUserByIDExpectation {
	if mmSaveUserByID.mock.funcSaveUserByID != nil {
		mmSaveUserByID.mock.t.Fatalf("UserStorageMock.SaveUserByID mock is already set by Set")
	}

	expectation := &UserStorageMockSaveUserByIDExpectation{
		mock:   mmSaveUserByID.mock,
		params: &UserStorageMockSaveUserByIDParams{ctx, userID, rec},
	}
	mmSaveUserByID.expectations = append(mmSaveUserByID.expectations, expectation)
	return expectation
}

// Then sets up userStorage.SaveUserByID return parameters for the expectation previously defined by the When method
func (e *UserStorageMockSaveUserByIDExpectation) Then(err error) *UserStorageMock {
	e.results = &UserStorageMockSaveUserByIDResults{err}
	return e.mock
}

// SaveUserByID implements messages.userStorage
func (mmSaveUserByID *UserStorageMock) SaveUserByID(ctx context.Context, userID int64, rec user.Record) (err error) {
	mm_atomic.AddUint64(&mmSaveUserByID.beforeSaveUserByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveUserByID.afterSaveUserByIDCounter, 1)

	if mmSaveUserByID.inspectFuncSaveUserByID != nil {
		mmSaveUserByID.inspectFuncSaveUserByID(ctx, userID, rec)
	}

	mm_params := &UserStorageMockSaveUserByIDParams{ctx, userID, rec}

	// Record call args
	mmSaveUserByID.SaveUserByIDMock.mutex.Lock()
	mmSaveUserByID.SaveUserByIDMock.callArgs = append(mmSaveUserByID.SaveUserByIDMock.callArgs, mm_params)
	mmSaveUserByID.SaveUserByIDMock.mutex.Unlock()

	for _, e := range mmSaveUserByID.SaveUserByIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSaveUserByID.SaveUserByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveUserByID.SaveUserByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveUserByID.SaveUserByIDMock.defaultExpectation.params
		mm_got := UserStorageMockSaveUserByIDParams{ctx, userID, rec}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveUserByID.t.Errorf("UserStorageMock.SaveUserByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveUserByID.SaveUserByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveUserByID.t.Fatal("No results are set for the UserStorageMock.SaveUserByID")
		}
		return (*mm_results).err
	}
	if mmSaveUserByID.funcSaveUserByID != nil {
		return mmSaveUserByID.funcSaveUserByID(ctx, userID, rec)
	}
	mmSaveUserByID.t.Fatalf("Unexpected call to UserStorageMock.SaveUserByID. %v %v %v", ctx, userID, rec)
	return
}

// SaveUserByIDAfterCounter returns a count of finished UserStorageMock.SaveUserByID invocations
func (mmSaveUserByID *UserStorageMock) SaveUserByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveUserByID.afterSaveUserByIDCounter)
}

// SaveUserByIDBeforeCounter returns a count of UserStorageMock.SaveUserByID invocations
func (mmSaveUserByID *UserStorageMock) SaveUserByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveUserByID.beforeSaveUserByIDCounter)
}

// Calls returns a list of arguments used in each call to UserStorageMock.SaveUserByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveUserByID *mUserStorageMockSaveUserByID) Calls() []*UserStorageMockSaveUserByIDParams {
	mmSaveUserByID.mutex.RLock()

	argCopy := make([]*UserStorageMockSaveUserByIDParams, len(mmSaveUserByID.callArgs))
	copy(argCopy, mmSaveUserByID.callArgs)

	mmSaveUserByID.mutex.RUnlock()

	return argCopy
}

// MinimockSaveUserByIDDone returns true if the count of the SaveUserByID invocations corresponds
// the number of defined expectations
func (m *UserStorageMock) MinimockSaveUserByIDDone() bool {
	for _, e := range m.SaveUserByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveUserByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveUserByIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveUserByID != nil && mm_atomic.LoadUint64(&m.afterSaveUserByIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockSaveUserByIDInspect logs each unmet expectation
func (m *UserStorageMock) MinimockSaveUserByIDInspect() {
	for _, e := range m.SaveUserByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserStorageMock.SaveUserByID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveUserByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveUserByIDCounter) < 1 {
		if m.SaveUserByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserStorageMock.SaveUserByID")
		} else {
			m.t.Errorf("Expected call to UserStorageMock.SaveUserByID with params: %#v", *m.SaveUserByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveUserByID != nil && mm_atomic.LoadUint64(&m.afterSaveUserByIDCounter) < 1 {
		m.t.Error("Expected call to UserStorageMock.SaveUserByID")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserStorageMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetRateInspect()

		m.MinimockGetUserByIDInspect()

		m.MinimockSaveExpenseInspect()

		m.MinimockSaveUserByIDInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserStorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserStorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetRateDone() &&
		m.MinimockGetUserByIDDone() &&
		m.MinimockSaveExpenseDone() &&
		m.MinimockSaveUserByIDDone()
}
