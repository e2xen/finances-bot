package mock

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i max.ks1230/project-base/internal/model/reports.expensesStorage -o ./mock/expenses_storage_mock.go -n ExpensesStorageMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"max.ks1230/project-base/internal/entity/currency"
	"max.ks1230/project-base/internal/entity/user"
)

// ExpensesStorageMock implements reports.expensesStorage
type ExpensesStorageMock struct {
	t minimock.Tester

	funcGetRate          func(ctx context.Context, name string) (r1 currency.Rate, err error)
	inspectFuncGetRate   func(ctx context.Context, name string)
	afterGetRateCounter  uint64
	beforeGetRateCounter uint64
	GetRateMock          mExpensesStorageMockGetRate

	funcGetUserByID          func(ctx context.Context, userID int64) (r1 user.Record, err error)
	inspectFuncGetUserByID   func(ctx context.Context, userID int64)
	afterGetUserByIDCounter  uint64
	beforeGetUserByIDCounter uint64
	GetUserByIDMock          mExpensesStorageMockGetUserByID

	funcGetUserExpenses          func(ctx context.Context, userID int64) (ea1 []user.ExpenseRecord, err error)
	inspectFuncGetUserExpenses   func(ctx context.Context, userID int64)
	afterGetUserExpensesCounter  uint64
	beforeGetUserExpensesCounter uint64
	GetUserExpensesMock          mExpensesStorageMockGetUserExpenses
}

// NewExpensesStorageMock returns a mock for reports.expensesStorage
func NewExpensesStorageMock(t minimock.Tester) *ExpensesStorageMock {
	m := &ExpensesStorageMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetRateMock = mExpensesStorageMockGetRate{mock: m}
	m.GetRateMock.callArgs = []*ExpensesStorageMockGetRateParams{}

	m.GetUserByIDMock = mExpensesStorageMockGetUserByID{mock: m}
	m.GetUserByIDMock.callArgs = []*ExpensesStorageMockGetUserByIDParams{}

	m.GetUserExpensesMock = mExpensesStorageMockGetUserExpenses{mock: m}
	m.GetUserExpensesMock.callArgs = []*ExpensesStorageMockGetUserExpensesParams{}

	return m
}

type mExpensesStorageMockGetRate struct {
	mock               *ExpensesStorageMock
	defaultExpectation *ExpensesStorageMockGetRateExpectation
	expectations       []*ExpensesStorageMockGetRateExpectation

	callArgs []*ExpensesStorageMockGetRateParams
	mutex    sync.RWMutex
}

// ExpensesStorageMockGetRateExpectation specifies expectation struct of the expensesStorage.GetRate
type ExpensesStorageMockGetRateExpectation struct {
	mock    *ExpensesStorageMock
	params  *ExpensesStorageMockGetRateParams
	results *ExpensesStorageMockGetRateResults
	Counter uint64
}

// ExpensesStorageMockGetRateParams contains parameters of the expensesStorage.GetRate
type ExpensesStorageMockGetRateParams struct {
	ctx  context.Context
	name string
}

// ExpensesStorageMockGetRateResults contains results of the expensesStorage.GetRate
type ExpensesStorageMockGetRateResults struct {
	r1  currency.Rate
	err error
}

// Expect sets up expected params for expensesStorage.GetRate
func (mmGetRate *mExpensesStorageMockGetRate) Expect(ctx context.Context, name string) *mExpensesStorageMockGetRate {
	if mmGetRate.mock.funcGetRate != nil {
		mmGetRate.mock.t.Fatalf("ExpensesStorageMock.GetRate mock is already set by Set")
	}

	if mmGetRate.defaultExpectation == nil {
		mmGetRate.defaultExpectation = &ExpensesStorageMockGetRateExpectation{}
	}

	mmGetRate.defaultExpectation.params = &ExpensesStorageMockGetRateParams{ctx, name}
	for _, e := range mmGetRate.expectations {
		if minimock.Equal(e.params, mmGetRate.defaultExpectation.params) {
			mmGetRate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRate.defaultExpectation.params)
		}
	}

	return mmGetRate
}

// Inspect accepts an inspector function that has same arguments as the expensesStorage.GetRate
func (mmGetRate *mExpensesStorageMockGetRate) Inspect(f func(ctx context.Context, name string)) *mExpensesStorageMockGetRate {
	if mmGetRate.mock.inspectFuncGetRate != nil {
		mmGetRate.mock.t.Fatalf("Inspect function is already set for ExpensesStorageMock.GetRate")
	}

	mmGetRate.mock.inspectFuncGetRate = f

	return mmGetRate
}

// Return sets up results that will be returned by expensesStorage.GetRate
func (mmGetRate *mExpensesStorageMockGetRate) Return(r1 currency.Rate, err error) *ExpensesStorageMock {
	if mmGetRate.mock.funcGetRate != nil {
		mmGetRate.mock.t.Fatalf("ExpensesStorageMock.GetRate mock is already set by Set")
	}

	if mmGetRate.defaultExpectation == nil {
		mmGetRate.defaultExpectation = &ExpensesStorageMockGetRateExpectation{mock: mmGetRate.mock}
	}
	mmGetRate.defaultExpectation.results = &ExpensesStorageMockGetRateResults{r1, err}
	return mmGetRate.mock
}

// Set uses given function f to mock the expensesStorage.GetRate method
func (mmGetRate *mExpensesStorageMockGetRate) Set(f func(ctx context.Context, name string) (r1 currency.Rate, err error)) *ExpensesStorageMock {
	if mmGetRate.defaultExpectation != nil {
		mmGetRate.mock.t.Fatalf("Default expectation is already set for the expensesStorage.GetRate method")
	}

	if len(mmGetRate.expectations) > 0 {
		mmGetRate.mock.t.Fatalf("Some expectations are already set for the expensesStorage.GetRate method")
	}

	mmGetRate.mock.funcGetRate = f
	return mmGetRate.mock
}

// When sets expectation for the expensesStorage.GetRate which will trigger the result defined by the following
// Then helper
func (mmGetRate *mExpensesStorageMockGetRate) When(ctx context.Context, name string) *ExpensesStorageMockGetRateExpectation {
	if mmGetRate.mock.funcGetRate != nil {
		mmGetRate.mock.t.Fatalf("ExpensesStorageMock.GetRate mock is already set by Set")
	}

	expectation := &ExpensesStorageMockGetRateExpectation{
		mock:   mmGetRate.mock,
		params: &ExpensesStorageMockGetRateParams{ctx, name},
	}
	mmGetRate.expectations = append(mmGetRate.expectations, expectation)
	return expectation
}

// Then sets up expensesStorage.GetRate return parameters for the expectation previously defined by the When method
func (e *ExpensesStorageMockGetRateExpectation) Then(r1 currency.Rate, err error) *ExpensesStorageMock {
	e.results = &ExpensesStorageMockGetRateResults{r1, err}
	return e.mock
}

// GetRate implements reports.expensesStorage
func (mmGetRate *ExpensesStorageMock) GetRate(ctx context.Context, name string) (r1 currency.Rate, err error) {
	mm_atomic.AddUint64(&mmGetRate.beforeGetRateCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRate.afterGetRateCounter, 1)

	if mmGetRate.inspectFuncGetRate != nil {
		mmGetRate.inspectFuncGetRate(ctx, name)
	}

	mm_params := &ExpensesStorageMockGetRateParams{ctx, name}

	// Record call args
	mmGetRate.GetRateMock.mutex.Lock()
	mmGetRate.GetRateMock.callArgs = append(mmGetRate.GetRateMock.callArgs, mm_params)
	mmGetRate.GetRateMock.mutex.Unlock()

	for _, e := range mmGetRate.GetRateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmGetRate.GetRateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRate.GetRateMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRate.GetRateMock.defaultExpectation.params
		mm_got := ExpensesStorageMockGetRateParams{ctx, name}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRate.t.Errorf("ExpensesStorageMock.GetRate got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRate.GetRateMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRate.t.Fatal("No results are set for the ExpensesStorageMock.GetRate")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmGetRate.funcGetRate != nil {
		return mmGetRate.funcGetRate(ctx, name)
	}
	mmGetRate.t.Fatalf("Unexpected call to ExpensesStorageMock.GetRate. %v %v", ctx, name)
	return
}

// GetRateAfterCounter returns a count of finished ExpensesStorageMock.GetRate invocations
func (mmGetRate *ExpensesStorageMock) GetRateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRate.afterGetRateCounter)
}

// GetRateBeforeCounter returns a count of ExpensesStorageMock.GetRate invocations
func (mmGetRate *ExpensesStorageMock) GetRateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRate.beforeGetRateCounter)
}

// Calls returns a list of arguments used in each call to ExpensesStorageMock.GetRate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRate *mExpensesStorageMockGetRate) Calls() []*ExpensesStorageMockGetRateParams {
	mmGetRate.mutex.RLock()

	argCopy := make([]*ExpensesStorageMockGetRateParams, len(mmGetRate.callArgs))
	copy(argCopy, mmGetRate.callArgs)

	mmGetRate.mutex.RUnlock()

	return argCopy
}

// MinimockGetRateDone returns true if the count of the GetRate invocations corresponds
// the number of defined expectations
func (m *ExpensesStorageMock) MinimockGetRateDone() bool {
	for _, e := range m.GetRateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRate != nil && mm_atomic.LoadUint64(&m.afterGetRateCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetRateInspect logs each unmet expectation
func (m *ExpensesStorageMock) MinimockGetRateInspect() {
	for _, e := range m.GetRateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExpensesStorageMock.GetRate with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRateCounter) < 1 {
		if m.GetRateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExpensesStorageMock.GetRate")
		} else {
			m.t.Errorf("Expected call to ExpensesStorageMock.GetRate with params: %#v", *m.GetRateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRate != nil && mm_atomic.LoadUint64(&m.afterGetRateCounter) < 1 {
		m.t.Error("Expected call to ExpensesStorageMock.GetRate")
	}
}

type mExpensesStorageMockGetUserByID struct {
	mock               *ExpensesStorageMock
	defaultExpectation *ExpensesStorageMockGetUserByIDExpectation
	expectations       []*ExpensesStorageMockGetUserByIDExpectation

	callArgs []*ExpensesStorageMockGetUserByIDParams
	mutex    sync.RWMutex
}

// ExpensesStorageMockGetUserByIDExpectation specifies expectation struct of the expensesStorage.GetUserByID
type ExpensesStorageMockGetUserByIDExpectation struct {
	mock    *ExpensesStorageMock
	params  *ExpensesStorageMockGetUserByIDParams
	results *ExpensesStorageMockGetUserByIDResults
	Counter uint64
}

// ExpensesStorageMockGetUserByIDParams contains parameters of the expensesStorage.GetUserByID
type ExpensesStorageMockGetUserByIDParams struct {
	ctx    context.Context
	userID int64
}

// ExpensesStorageMockGetUserByIDResults contains results of the expensesStorage.GetUserByID
type ExpensesStorageMockGetUserByIDResults struct {
	r1  user.Record
	err error
}

// Expect sets up expected params for expensesStorage.GetUserByID
func (mmGetUserByID *mExpensesStorageMockGetUserByID) Expect(ctx context.Context, userID int64) *mExpensesStorageMockGetUserByID {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("ExpensesStorageMock.GetUserByID mock is already set by Set")
	}

	if mmGetUserByID.defaultExpectation == nil {
		mmGetUserByID.defaultExpectation = &ExpensesStorageMockGetUserByIDExpectation{}
	}

	mmGetUserByID.defaultExpectation.params = &ExpensesStorageMockGetUserByIDParams{ctx, userID}
	for _, e := range mmGetUserByID.expectations {
		if minimock.Equal(e.params, mmGetUserByID.defaultExpectation.params) {
			mmGetUserByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserByID.defaultExpectation.params)
		}
	}

	return mmGetUserByID
}

// Inspect accepts an inspector function that has same arguments as the expensesStorage.GetUserByID
func (mmGetUserByID *mExpensesStorageMockGetUserByID) Inspect(f func(ctx context.Context, userID int64)) *mExpensesStorageMockGetUserByID {
	if mmGetUserByID.mock.inspectFuncGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("Inspect function is already set for ExpensesStorageMock.GetUserByID")
	}

	mmGetUserByID.mock.inspectFuncGetUserByID = f

	return mmGetUserByID
}

// Return sets up results that will be returned by expensesStorage.GetUserByID
func (mmGetUserByID *mExpensesStorageMockGetUserByID) Return(r1 user.Record, err error) *ExpensesStorageMock {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("ExpensesStorageMock.GetUserByID mock is already set by Set")
	}

	if mmGetUserByID.defaultExpectation == nil {
		mmGetUserByID.defaultExpectation = &ExpensesStorageMockGetUserByIDExpectation{mock: mmGetUserByID.mock}
	}
	mmGetUserByID.defaultExpectation.results = &ExpensesStorageMockGetUserByIDResults{r1, err}
	return mmGetUserByID.mock
}

// Set uses given function f to mock the expensesStorage.GetUserByID method
func (mmGetUserByID *mExpensesStorageMockGetUserByID) Set(f func(ctx context.Context, userID int64) (r1 user.Record, err error)) *ExpensesStorageMock {
	if mmGetUserByID.defaultExpectation != nil {
		mmGetUserByID.mock.t.Fatalf("Default expectation is already set for the expensesStorage.GetUserByID method")
	}

	if len(mmGetUserByID.expectations) > 0 {
		mmGetUserByID.mock.t.Fatalf("Some expectations are already set for the expensesStorage.GetUserByID method")
	}

	mmGetUserByID.mock.funcGetUserByID = f
	return mmGetUserByID.mock
}

// When sets expectation for the expensesStorage.GetUserByID which will trigger the result defined by the following
// Then helper
func (mmGetUserByID *mExpensesStorageMockGetUserByID) When(ctx context.Context, userID int64) *ExpensesStorageMockGetUserByIDExpectation {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("ExpensesStorageMock.GetUserByID mock is already set by Set")
	}

	expectation := &ExpensesStorageMockGetUserByIDExpectation{
		mock:   mmGetUserByID.mock,
		params: &ExpensesStorageMockGetUserByIDParams{ctx, userID},
	}
	mmGetUserByID.expectations = append(mmGetUserByID.expectations, expectation)
	return expectation
}

// Then sets up expensesStorage.GetUserByID return parameters for the expectation previously defined by the When method
func (e *ExpensesStorageMockGetUserByIDExpectation) Then(r1 user.Record, err error) *ExpensesStorageMock {
	e.results = &ExpensesStorageMockGetUserByIDResults{r1, err}
	return e.mock
}

// GetUserByID implements reports.expensesStorage
func (mmGetUserByID *ExpensesStorageMock) GetUserByID(ctx context.Context, userID int64) (r1 user.Record, err error) {
	mm_atomic.AddUint64(&mmGetUserByID.beforeGetUserByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserByID.afterGetUserByIDCounter, 1)

	if mmGetUserByID.inspectFuncGetUserByID != nil {
		mmGetUserByID.inspectFuncGetUserByID(ctx, userID)
	}

	mm_params := &ExpensesStorageMockGetUserByIDParams{ctx, userID}

	// Record call args
	mmGetUserByID.GetUserByIDMock.mutex.Lock()
	mmGetUserByID.GetUserByIDMock.callArgs = append(mmGetUserByID.GetUserByIDMock.callArgs, mm_params)
	mmGetUserByID.GetUserByIDMock.mutex.Unlock()

	for _, e := range mmGetUserByID.GetUserByIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmGetUserByID.GetUserByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserByID.GetUserByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserByID.GetUserByIDMock.defaultExpectation.params
		mm_got := ExpensesStorageMockGetUserByIDParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserByID.t.Errorf("ExpensesStorageMock.GetUserByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserByID.GetUserByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserByID.t.Fatal("No results are set for the ExpensesStorageMock.GetUserByID")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmGetUserByID.funcGetUserByID != nil {
		return mmGetUserByID.funcGetUserByID(ctx, userID)
	}
	mmGetUserByID.t.Fatalf("Unexpected call to ExpensesStorageMock.GetUserByID. %v %v", ctx, userID)
	return
}

// GetUserByIDAfterCounter returns a count of finished ExpensesStorageMock.GetUserByID invocations
func (mmGetUserByID *ExpensesStorageMock) GetUserByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByID.afterGetUserByIDCounter)
}

// GetUserByIDBeforeCounter returns a count of ExpensesStorageMock.GetUserByID invocations
func (mmGetUserByID *ExpensesStorageMock) GetUserByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByID.beforeGetUserByIDCounter)
}

// Calls returns a list of arguments used in each call to ExpensesStorageMock.GetUserByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserByID *mExpensesStorageMockGetUserByID) Calls() []*ExpensesStorageMockGetUserByIDParams {
	mmGetUserByID.mutex.RLock()

	argCopy := make([]*ExpensesStorageMockGetUserByIDParams, len(mmGetUserByID.callArgs))
	copy(argCopy, mmGetUserByID.callArgs)

	mmGetUserByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserByIDDone returns true if the count of the GetUserByID invocations corresponds
// the number of defined expectations
func (m *ExpensesStorageMock) MinimockGetUserByIDDone() bool {
	for _, e := range m.GetUserByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserByIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserByID != nil && mm_atomic.LoadUint64(&m.afterGetUserByIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetUserByIDInspect logs each unmet expectation
func (m *ExpensesStorageMock) MinimockGetUserByIDInspect() {
	for _, e := range m.GetUserByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExpensesStorageMock.GetUserByID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserByIDCounter) < 1 {
		if m.GetUserByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExpensesStorageMock.GetUserByID")
		} else {
			m.t.Errorf("Expected call to ExpensesStorageMock.GetUserByID with params: %#v", *m.GetUserByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserByID != nil && mm_atomic.LoadUint64(&m.afterGetUserByIDCounter) < 1 {
		m.t.Error("Expected call to ExpensesStorageMock.GetUserByID")
	}
}

type mExpensesStorageMockGetUserExpenses struct {
	mock               *ExpensesStorageMock
	defaultExpectation *ExpensesStorageMockGetUserExpensesExpectation
	expectations       []*ExpensesStorageMockGetUserExpensesExpectation

	callArgs []*ExpensesStorageMockGetUserExpensesParams
	mutex    sync.RWMutex
}

// ExpensesStorageMockGetUserExpensesExpectation specifies expectation struct of the expensesStorage.GetUserExpenses
type ExpensesStorageMockGetUserExpensesExpectation struct {
	mock    *ExpensesStorageMock
	params  *ExpensesStorageMockGetUserExpensesParams
	results *ExpensesStorageMockGetUserExpensesResults
	Counter uint64
}

// ExpensesStorageMockGetUserExpensesParams contains parameters of the expensesStorage.GetUserExpenses
type ExpensesStorageMockGetUserExpensesParams struct {
	ctx    context.Context
	userID int64
}

// ExpensesStorageMockGetUserExpensesResults contains results of the expensesStorage.GetUserExpenses
type ExpensesStorageMockGetUserExpensesResults struct {
	ea1 []user.ExpenseRecord
	err error
}

// Expect sets up expected params for expensesStorage.GetUserExpenses
func (mmGetUserExpenses *mExpensesStorageMockGetUserExpenses) Expect(ctx context.Context, userID int64) *mExpensesStorageMockGetUserExpenses {
	if mmGetUserExpenses.mock.funcGetUserExpenses != nil {
		mmGetUserExpenses.mock.t.Fatalf("ExpensesStorageMock.GetUserExpenses mock is already set by Set")
	}

	if mmGetUserExpenses.defaultExpectation == nil {
		mmGetUserExpenses.defaultExpectation = &ExpensesStorageMockGetUserExpensesExpectation{}
	}

	mmGetUserExpenses.defaultExpectation.params = &ExpensesStorageMockGetUserExpensesParams{ctx, userID}
	for _, e := range mmGetUserExpenses.expectations {
		if minimock.Equal(e.params, mmGetUserExpenses.defaultExpectation.params) {
			mmGetUserExpenses.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserExpenses.defaultExpectation.params)
		}
	}

	return mmGetUserExpenses
}

// Inspect accepts an inspector function that has same arguments as the expensesStorage.GetUserExpenses
func (mmGetUserExpenses *mExpensesStorageMockGetUserExpenses) Inspect(f func(ctx context.Context, userID int64)) *mExpensesStorageMockGetUserExpenses {
	if mmGetUserExpenses.mock.inspectFuncGetUserExpenses != nil {
		mmGetUserExpenses.mock.t.Fatalf("Inspect function is already set for ExpensesStorageMock.GetUserExpenses")
	}

	mmGetUserExpenses.mock.inspectFuncGetUserExpenses = f

	return mmGetUserExpenses
}

// Return sets up results that will be returned by expensesStorage.GetUserExpenses
func (mmGetUserExpenses *mExpensesStorageMockGetUserExpenses) Return(ea1 []user.ExpenseRecord, err error) *ExpensesStorageMock {
	if mmGetUserExpenses.mock.funcGetUserExpenses != nil {
		mmGetUserExpenses.mock.t.Fatalf("ExpensesStorageMock.GetUserExpenses mock is already set by Set")
	}

	if mmGetUserExpenses.defaultExpectation == nil {
		mmGetUserExpenses.defaultExpectation = &ExpensesStorageMockGetUserExpensesExpectation{mock: mmGetUserExpenses.mock}
	}
	mmGetUserExpenses.defaultExpectation.results = &ExpensesStorageMockGetUserExpensesResults{ea1, err}
	return mmGetUserExpenses.mock
}

// Set uses given function f to mock the expensesStorage.GetUserExpenses method
func (mmGetUserExpenses *mExpensesStorageMockGetUserExpenses) Set(f func(ctx context.Context, userID int64) (ea1 []user.ExpenseRecord, err error)) *ExpensesStorageMock {
	if mmGetUserExpenses.defaultExpectation != nil {
		mmGetUserExpenses.mock.t.Fatalf("Default expectation is already set for the expensesStorage.GetUserExpenses method")
	}

	if len(mmGetUserExpenses.expectations) > 0 {
		mmGetUserExpenses.mock.t.Fatalf("Some expectations are already set for the expensesStorage.GetUserExpenses method")
	}

	mmGetUserExpenses.mock.funcGetUserExpenses = f
	return mmGetUserExpenses.mock
}

// When sets expectation for the expensesStorage.GetUserExpenses which will trigger the result defined by the following
// Then helper
func (mmGetUserExpenses *mExpensesStorageMockGetUserExpenses) When(ctx context.Context, userID int64) *ExpensesStorageMockGetUserExpensesExpectation {
	if mmGetUserExpenses.mock.funcGetUserExpenses != nil {
		mmGetUserExpenses.mock.t.Fatalf("ExpensesStorageMock.GetUserExpenses mock is already set by Set")
	}

	expectation := &ExpensesStorageMockGetUserExpensesExpectation{
		mock:   mmGetUserExpenses.mock,
		params: &ExpensesStorageMockGetUserExpensesParams{ctx, userID},
	}
	mmGetUserExpenses.expectations = append(mmGetUserExpenses.expectations, expectation)
	return expectation
}

// Then sets up expensesStorage.GetUserExpenses return parameters for the expectation previously defined by the When method
func (e *ExpensesStorageMockGetUserExpensesExpectation) Then(ea1 []user.ExpenseRecord, err error) *ExpensesStorageMock {
	e.results = &ExpensesStorageMockGetUserExpensesResults{ea1, err}
	return e.mock
}

// GetUserExpenses implements reports.expensesStorage
func (mmGetUserExpenses *ExpensesStorageMock) GetUserExpenses(ctx context.Context, userID int64) (ea1 []user.ExpenseRecord, err error) {
	mm_atomic.AddUint64(&mmGetUserExpenses.beforeGetUserExpensesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserExpenses.afterGetUserExpensesCounter, 1)

	if mmGetUserExpenses.inspectFuncGetUserExpenses != nil {
		mmGetUserExpenses.inspectFuncGetUserExpenses(ctx, userID)
	}

	mm_params := &ExpensesStorageMockGetUserExpensesParams{ctx, userID}

	// Record call args
	mmGetUserExpenses.GetUserExpensesMock.mutex.Lock()
	mmGetUserExpenses.GetUserExpensesMock.callArgs = append(mmGetUserExpenses.GetUserExpensesMock.callArgs, mm_params)
	mmGetUserExpenses.GetUserExpensesMock.mutex.Unlock()

	for _, e := range mmGetUserExpenses.GetUserExpensesMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ea1, e.results.err
		}
	}

	if mmGetUserExpenses.GetUserExpensesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserExpenses.GetUserExpensesMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserExpenses.GetUserExpensesMock.defaultExpectation.params
		mm_got := ExpensesStorageMockGetUserExpensesParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserExpenses.t.Errorf("ExpensesStorageMock.GetUserExpenses got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserExpenses.GetUserExpensesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserExpenses.t.Fatal("No results are set for the ExpensesStorageMock.GetUserExpenses")
		}
		return (*mm_results).ea1, (*mm_results).err
	}
	if mmGetUserExpenses.funcGetUserExpenses != nil {
		return mmGetUserExpenses.funcGetUserExpenses(ctx, userID)
	}
	mmGetUserExpenses.t.Fatalf("Unexpected call to ExpensesStorageMock.GetUserExpenses. %v %v", ctx, userID)
	return
}

// GetUserExpensesAfterCounter returns a count of finished ExpensesStorageMock.GetUserExpenses invocations
func (mmGetUserExpenses *ExpensesStorageMock) GetUserExpensesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserExpenses.afterGetUserExpensesCounter)
}

// GetUserExpensesBeforeCounter returns a count of ExpensesStorageMock.GetUserExpenses invocations
func (mmGetUserExpenses *ExpensesStorageMock) GetUserExpensesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserExpenses.beforeGetUserExpensesCounter)
}

// Calls returns a list of arguments used in each call to ExpensesStorageMock.GetUserExpenses.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserExpenses *mExpensesStorageMockGetUserExpenses) Calls() []*ExpensesStorageMockGetUserExpensesParams {
	mmGetUserExpenses.mutex.RLock()

	argCopy := make([]*ExpensesStorageMockGetUserExpensesParams, len(mmGetUserExpenses.callArgs))
	copy(argCopy, mmGetUserExpenses.callArgs)

	mmGetUserExpenses.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserExpensesDone returns true if the count of the GetUserExpenses invocations corresponds
// the number of defined expectations
func (m *ExpensesStorageMock) MinimockGetUserExpensesDone() bool {
	for _, e := range m.GetUserExpensesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserExpensesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserExpensesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserExpenses != nil && mm_atomic.LoadUint64(&m.afterGetUserExpensesCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetUserExpensesInspect logs each unmet expectation
func (m *ExpensesStorageMock) MinimockGetUserExpensesInspect() {
	for _, e := range m.GetUserExpensesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ExpensesStorageMock.GetUserExpenses with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserExpensesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserExpensesCounter) < 1 {
		if m.GetUserExpensesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ExpensesStorageMock.GetUserExpenses")
		} else {
			m.t.Errorf("Expected call to ExpensesStorageMock.GetUserExpenses with params: %#v", *m.GetUserExpensesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserExpenses != nil && mm_atomic.LoadUint64(&m.afterGetUserExpensesCounter) < 1 {
		m.t.Error("Expected call to ExpensesStorageMock.GetUserExpenses")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ExpensesStorageMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetRateInspect()

		m.MinimockGetUserByIDInspect()

		m.MinimockGetUserExpensesInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ExpensesStorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ExpensesStorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetRateDone() &&
		m.MinimockGetUserByIDDone() &&
		m.MinimockGetUserExpensesDone()
}
